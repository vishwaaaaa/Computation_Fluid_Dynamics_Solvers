// AERO623 Project 3
// DG Overall Solver

#define _USE_MATH_DEFINES
#include <cmath>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <iomanip>
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <Eigen/Core>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <chrono>
using namespace std;
using namespace Eigen;

MatrixXd FileRead(string filename, int nrow, int ncol) {
    
  // Define the matrix to store the data
  MatrixXd matrix(nrow,ncol);

  // Open the input file
  ifstream file(filename);
  if (!file.is_open()) {
    cout << "Error opening file" << endl;
    return matrix;
  }

  // Read the file line by line
  string line;
  int row = 0;
  while (getline(file, line)) {
    // Split the line into separate values
    istringstream iss(line);
    double value;
    int col = 0;
    while (iss >> value) {
      // Resize the matrix if necessary
      /*if (row == matrix.rows()) {
        matrix.conservativeResize(matrix.rows() + 1, Eigen::NoChange);
      }
      if (col == matrix.cols()) {
        matrix.conservativeResize(Eigen::NoChange, matrix.cols() + 1);
      }*/
      // Store the value in the matrix
      matrix(row, col) = value;
      col++;
    }
    row++;
    if (row%1000 == 0) {
        cout << row << "\n";
    }
  }
  /*for (int i=0; i<matrix.rows(); i++) {
    for (int j=0; j<matrix.cols(); j++) {
        if (abs(matrix(i,j)-int(matrix(i,j))) < 1e-6) {
            matrix(i,j) = int(matrix(i,j)+0.5);
        }
    }
  }*/

  // Close the file
  file.close();

  //Output the matrix
  return matrix;
}

void FileWrite(string filename, MatrixXd matrix) {
    ofstream file(filename);

    // Check if file opened successfully
    if (!file.is_open())
    {
        cerr << "Failed to open file" << endl;
    }

    // Write the matrix to the file
    for (int i = 0; i < matrix.rows(); i++)
    {
        for (int j = 0; j < matrix.cols(); j++)
        {
            file << matrix(i, j) << " ";
        }
        file << std::endl;
    }

    // Close the file
    file.close();
}

struct Flux
{
    MatrixXd F;
    double smag;
};

struct Flux RoeFlux(MatrixXd UL, MatrixXd UR, double gamma, MatrixXd n)
{
    // declaring variables:
    double gmi, rL, uL, vL, unL, qL, pL, rHL, HL, cL,
        rR, uR, vR, unR, qR, pR, rHR, HR, cR, 
        di, d1, ui, vi, Hi, af, ucp, c2, ci, ci1, l3, 
        epsilon, s1, s2, G1, G2, C1, C2, smag;

    MatrixXd FL(4,1);
    MatrixXd FR(4,1);
    MatrixXd du(4,1);
    MatrixXd l(3,1);
    MatrixXd FF(1,4);

    gmi = gamma - 1.0;
    
    // process left state
    rL = UL(0,0);
    uL = UL(0,1)/rL;
    vL = UL(0,2)/rL;
    unL = uL*n(0,0) + vL*n(0,1);
    qL = sqrt(pow(UL(0,1), 2) + pow(UL(0,2), 2))/rL;
    pL = gmi*(UL(0,3) - 0.5*rL*pow(qL, 2));

    if ((pL<0) || (rL<0))
    {
        //cout << "Non-physical state!";
        //cout << UL;
    }

    if (pL<0)
    {
        pL = -pL;
    }

    if (rL<0)
    {
        rL = -rL;
    }

    rHL = UL(0,3) + pL;
    HL = rHL/rL;
    cL = sqrt(gamma*pL/rL);

    // left flux
    FL(0,0) = rL*unL;
    FL(1,0) = UL(0,1)*unL + pL*n(0,0);
    FL(2,0) = UL(0,2)*unL + pL*n(0,1);
    FL(3,0) = rHL*unL;

    // process right state
    rR = UR(0,0);
    uR = UR(0,1)/rR;
    vR = UR(0,2)/rR;
    unR = uR*n(0,0) + vR*n(0,1);
    qR = sqrt(pow(UR(0,1),2) + pow(UR(0,2), 2))/rR;
    pR = gmi*(UR(0,3) - 0.5*rR*pow(qR,2));

    if ((pR<0) || (rR<0))
    {
        //cout << "Non-physical state!";
        //cout << UR;
    }

    if (pR<0)
    {
        pR = -pR;
    }

    if (rR<0)
    {
        rR = -rR;
    }

    rHR = UR(0,3) + pR;
    HR = rHR/rR;
    cR = sqrt(gamma*pR/rR);

    // right flux
    FR(0,0) = rR*unR;
    FR(1,0) = UR(0,1)*unR + pR*n(0,0);
    FR(2,0) = UR(0,2)*unR + pR*n(0,1);
    FR(3,0) = rHR*unR;

    // difference in states
    
    du(0,0) = UR(0,0) - UL(0,0);
    du(1,0) = UR(0,1) - UL(0,1);
    du(2,0) = UR(0,2) - UL(0,2);
    du(3,0) = UR(0,3) - UL(0,3); 
    // Roe average
    di = sqrt(rR/rL);
    d1 = 1.0/(1.0+di);

    ui = (di*uR + uL)*d1;
    vi = (di*vR + vL)*d1;
    Hi = (di*HR + HL)*d1;

    af = 0.5*(ui*ui + vi*vi);
    ucp = ui*n(0,0) + vi*n(0,1);
    c2 = gmi*(Hi - af);

    if (c2 < 0)
    {
        //cout << "Non-physical state!";
        c2 = -c2;
    }

    ci = sqrt(c2);
    ci1 = 1.0/ci;

    // eigenvalues
    l(0,0) = ucp+ci;
    l(1,0) = ucp-ci;
    l(2,0) = ucp;

    // entropy fix
    epsilon = ci*0.1;

    for (int i=0; i<3; i++)
    {
        if ((l(i,0) < epsilon) && (l(i,0) > -epsilon))
        {
            l(i,0) = 0.5*(epsilon + l(i,0)*l(i,0)/epsilon);
        }
    }
    
    l(0,0) = abs(l(0,0));
    l(1,0) = abs(l(1,0));
    l(2,0) = abs(l(2,0));
    l3 = l(2,0);

    // average and half-difference of 1st and 2nd eigenvalues
    s1 = 0.5*(l(0,0) + l(1,0));
    s2 = 0.5*(l(0,0) - l(1,0));

    // left eigenvector product generators
    G1 = gmi*(af*du(0,0) - ui*du(1,0) - vi*du(2,0) + du(3,0));
    G2 = -ucp*du(0,0) + du(1,0)*n(0,0) + du(2,0)*n(0,1);

    // required functions of G1 and G2
    C1 = G1*(s1-l3)*ci1*ci1 + G2*s2*ci1;
    C2 = G1*s2*ci1 + G2*(s1-l3);
    
    
    // flux assembly
    FF(0,0) = 0.5*(FL(0,0) + FR(0,0)) - 0.5*(l3*du(0,0) + C1);
    FF(0,1) = 0.5*(FL(1,0) + FR(1,0)) - 0.5*(l3*du(1,0) + C1*ui + C2*n(0,0));
    FF(0,2) = 0.5*(FL(2,0) + FR(2,0)) - 0.5*(l3*du(2,0) + C1*vi + C2*n(0,1));
    FF(0,3) = 0.5*(FL(3,0) + FR(3,0)) - 0.5*(l3*du(3,0) + C1*Hi + C2*ucp);
    
    
    // max wave speed
    double smag0 = max(l(0,0), l(1,0));
    double smag1 = max(smag0, l(2,0));
    double smag2 = max(smag1, l3);  
    smag = smag2;
 
    Flux R1;
    
    //for (int i=0; i<4; i++) {
    //    R1.F(i) = F(0, i);
    //}
     
    R1.F = FF;
    R1.smag = smag;
    return R1;
}

struct Flux WallFlux(MatrixXd u_plus, double gamma, MatrixXd n)
{

    // declaring variables
    double gmi, vb_mag_sq, pb, rho_b, cb, smag;

    MatrixXd v(2,1);
    MatrixXd vb(2,1);

    gmi = gamma - 1.0;

    // velocity components next to boundary
    v(0,0) = u_plus(0,1)/u_plus(0,0);
    v(1,0) = u_plus(0,2)/u_plus(0,0);

    // velocity components at boundary
    vb(0,0) = v(0, 0) - (v(0,0)*n(0,0) + v(1,0)*n(0,1))*n(0,0);
    vb(1,0) = v(1,0) - (v(0,0)*n(0,0) + v(1,0)*n(0,1))*n(0,1);
    vb_mag_sq = vb(0,0)*vb(0,0) + vb(1,0)*vb(1,0);

    // pressure at boundary
    pb = gmi*(u_plus(0,3) - 0.5*u_plus(0,0)*vb_mag_sq);

    // flux calculation normal to boundary
    Flux R1;
    MatrixXd F(1,4);
    F(0,0) = 0;
    F(0,1) = pb*n(0,0);
    F(0,2) = pb*n(0,1);
    F(0,3) = 0;
    R1.F = F;

    // wave speed calculation
    rho_b = u_plus(0,0);
    cb = sqrt(gamma*pb/rho_b);
    R1.smag = cb + abs(vb(0,0)*n(0,0) + vb(1,0)*n(0,1));

    return R1;

}

MatrixXd FreeStream(double gamma, double M, double alpha)
{
    // declaring variables
    double a0, rho0, p0, pf, rhof, af, vf_sq, Ef, gmi;
    MatrixXd n(2, 1);
    MatrixXd vf(2, 1);
    MatrixXd U0(1, 4);
    
    // calculating necessary variables
    n(0,0) = cos(alpha);
    n(1,0) = sin(alpha);

    gmi = gamma-1.0;

    a0 = 1;
    rho0 = 1;
    p0 = pow(a0,2)*rho0/gamma;

    pf = p0*pow((1+gmi/2*pow(M,2)),-gamma/gmi);
    rhof = rho0*pow((pf/p0), 1/gamma);
    af = sqrt(gamma*pf*rhof);

    vf(0,0) = M*af*n(0,0);
    vf(1,0) = M*af*n(1,0);

    vf_sq = vf(0,0)*vf(0,0) + vf(1,0)*vf(1,0);

    Ef = (pf/gmi + rhof*vf_sq/2);

    // free-stream assembly
    U0(0,0) = rhof;
    U0(0,1) = rhof*vf(0,0);
    U0(0,2) = rhof*vf(1,0);
    U0(0,3) = Ef;

    return U0;
}

MatrixXd Basis(MatrixXd xy, int p) {
    double x = xy(0,0);
    double y = xy(0,1);
    int rank = (p+1)*(p+2)/2;
    MatrixXd phi(rank,1);
    switch (p) {
    case 0:
        phi(0,0) = 1;
        break;
    case 1:
        phi(0,0) = 1-x-y;
        phi(1,0) = x;
        phi(2,0) = y;
        break;
    case 2: 
        phi(0,0) = 1.0-3.0*x-3.0*y+2.0*x*x+4.0*x*y+2.0*y*y;
        phi(2,0) = -x+2.0*x*x;
        phi(5,0) = -y+2.0*y*y;
        phi(4,0) = 4.0*x*y;
        phi(3,0) = 4.0*y-4.0*x*y-4.0*y*y;
        phi(1,0) = 4.0*x-4.0*x*x-4.0*x*y;
        break;
    case 3:
        phi(0,0) = 1.0-11.0/2.0*x-11.0/2.0*y+9.0*x*x+18.0*x*y+9.0*y*y-9.0/2.0*x*x*x-
            27.0/2.0*x*x*y-27.0/2.0*x*y*y-9.0/2.0*y*y*y;
        phi(3,0)= x-9.0/2.0*x*x+9.0/2.0*x*x*x;
        phi(9,0) = y-9.0/2.0*y*y+9.0/2.0*y*y*y;
        phi(6,0) = -9.0/2.0*x*y+27.0/2.0*x*x*y;
        phi(8,0) = -9.0/2.0*x*y+27.0/2.0*x*y*y;
        phi(7,0) = -9.0/2.0*y+9.0/2.0*x*y+18.0*y*y-27.0/2.0*x*y*y-27.0/2.0*y*y*y;
        phi(4,0) = 9.0*y-45.0/2.0*x*y-
            45.0/2.0*y*y+27.0/2.0*x*x*y+27.0*x*y*y+27.0/2.0*y*y*y;
        phi(1,0) = 9.0*x-45.0/2.0*x*x-
            45.0/2.0*x*y+27.0/2.0*x*x*x+27.0*x*x*y+27.0/2.0*x*y*y;
        phi(2,0) = -9.0/2.0*x+18.0*x*x+9.0/2.0*x*y-27.0/2.0*x*x*x-27.0/2.0*x*x*y;
        phi(5,0) = 27.0*x*y-27.0*x*x*y-27.0*x*y*y;
    break;
    default:
        cout << "Invalid Order \n";
        phi(0,0) = 0;
        break;
    }
    return phi;
}

MatrixXd BasisGrad(MatrixXd xy, int p) {
    double x = xy(0,0);
    double y = xy(0,1);
    int rank = (p+1)*(p+2)/2;
    MatrixXd gphi(rank,2);
    switch (p){
    case 0:
        gphi(0,0) =  0.0;
        gphi(0,1) =  0.0; 
        break;
    case 1:
        gphi(0,0) =  -1.0;
        gphi(1,0) =  1.0;
        gphi(2,0) =  0.0;
        gphi(0,1) =  -1.0;
        gphi(1,1) =  0.0;
        gphi(2,1) =  1.0;
        break;
    case 2:
        gphi(0,0) =  -3.0+4.0*x+4.0*y;
        gphi(2,0) =  -1.0+4.0*x;
        gphi(5,0) =  0.0;
        gphi(4,0) =  4.0*y;
        gphi(3,0) =  -4.0*y;
        gphi(1,0) =  4.0-8.0*x-4.0*y;
        gphi(0,1) =  -3.0+4.0*x+4.0*y;
        gphi(2,1) =  0.0;
        gphi(5,1) =  -1.0+4.0*y;
        gphi(4,1) =  4.0*x;
        gphi(3,1) =  4.0-4.0*x-8.0*y;
        gphi(1,1) =  -4.0*x;
        break;
    case 3:
        gphi(0,0) =  -11.0/2.0+18.0*x+18.0*y-27.0/2.0*x*x-27.0*x*y-27.0/2.0*y*y;
        gphi(3,0) =  1.0-9.0*x+27.0/2.0*x*x;
        gphi(9,0) =  0.0;
        gphi(6,0) =  -9.0/2.0*y+27.0*x*y;
        gphi(8,0) =  -9.0/2.0*y+27.0/2.0*y*y;
        gphi(7,0) =  9.0/2.0*y-27.0/2.0*y*y;
        gphi(4,0) =  -45.0/2.0*y+27.0*x*y+27.0*y*y;
        gphi(1,0) =  9.0-45.0*x-45.0/2.0*y+81.0/2.0*x*x+54.0*x*y+27.0/2.0*y*y;
        gphi(2,0) =  -9.0/2.0+36.0*x+9.0/2.0*y-81.0/2.0*x*x-27.0*x*y;
        gphi(5,0) =  27.0*y-54.0*x*y-27.0*y*y;
        gphi(0,1) =  -11.0/2.0+18.0*x+18.0*y-27.0/2.0*x*x-27.0*x*y-27.0/2.0*y*y;
        gphi(3,1) =  0.0;
        gphi(9,1) =  1.0-9.0*y+27.0/2.0*y*y;
        gphi(6,1) =  -9.0/2.0*x+27.0/2.0*x*x;
        gphi(8,1) =  -9.0/2.0*x+27.0*x*y;
        gphi(7,1) =  -9.0/2.0+9.0/2.0*x+36.0*y-27.0*x*y-81.0/2.0*y*y;
        gphi(4,1) =  9.0-45.0/2.0*x-45.0*y+27.0/2.0*x*x+54.0*x*y+81.0/2.0*y*y;
        gphi(1,1) =  -45.0/2.0*x+27.0*x*x+27.0*x*y;
        gphi(2,1) =  9.0/2.0*x-27.0/2.0*x*x;
        gphi(5,1) =  27.0*x-27.0*x*x-54.0*x*y;
        break;
    default:
        cout << "Invalid Order \n";
        gphi(0,0) = 0;
    }
    return gphi;
}

MatrixXd BasisQuad(int p, int q) {
    int rank = (p + 1) * (p + 2) / 2;
    MatrixXi np(4, 3); np(0, 0) = 4; np(1, 0) = 4; np(2, 0) = 7; np(3, 0) = 13;
    np(0, 1) = 7; np(1, 1) = 7; np(2, 1) = 13; np(3, 1) = 19;
    np(0, 2) = 13; np(1, 2) = 13; np(2, 2) = 19; np(3, 2) = 33;
    MatrixXd b_quad(rank, np(p, q - 1));
    MatrixXd xy(np(p, q - 1), 2);
    for (int i = 0; i < np(p, q - 1); i++) {
        for (int j = 0; j < 2; j++) {
            xy(i, j) = 1;
        }
    }
    switch (p) {
    case 0: // arbitrary bc const. phi, so have taken same as Case 1  //
        switch (q)
        {
        case 1: // Order 3 Dunavant Points
            xy(0, 0) = xy(0, 0) / 3; xy(0, 1) = xy(0, 1) / 3;
            xy(1, 0) = 3 * xy(1, 0) / 5; xy(1, 1) = xy(1, 1) / 5;
            xy(2, 0) = xy(2, 0) / 5; xy(2, 1) = xy(2, 1) / 5;
            xy(3, 0) = xy(3, 0) / 5; xy(3, 1) = 3 * xy(3, 1) / 5;
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;

        case 2: // Order 5 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.059715871789770; xy(1, 1) = xy(1, 1) * 0.470142064105115;
            xy(2, 0) = xy(2, 0) * 0.470142064105115; xy(2, 1) = xy(2, 1) * 0.470142064105115;
            xy(3, 0) = xy(3, 0) * 0.470142064105115; xy(3, 1) = xy(3, 1) * 0.059715871789770;
            xy(4, 0) = xy(4, 0) * 0.797426985353087; xy(4, 1) = xy(4, 1) * 0.101286507323456;
            xy(5, 0) = xy(5, 0) * 0.101286507323456; xy(5, 1) = xy(5, 1) * 0.101286507323456;
            xy(6, 0) = xy(6, 0) * 0.101286507323456; xy(6, 1) = xy(6, 1) * 0.797426985353087;
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;
        case 3: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;
        }
        break;
    case 1:
        switch (q)
        {
        case 1: // Order 3 Dunavant Points
            xy(0, 0) = xy(0, 0) / 3; xy(0, 1) = xy(0, 1) / 3;
            xy(1, 0) = 3 * xy(1, 0) / 5; xy(1, 1) = xy(1, 1) / 5;
            xy(2, 0) = xy(2, 0) / 5; xy(2, 1) = xy(2, 1) / 5;
            xy(3, 0) = xy(3, 0) / 5; xy(3, 1) = 3 * xy(3, 1) / 5;
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;
        case 2: // Order 5 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.059715871789770; xy(1, 1) = xy(1, 1) * 0.470142064105115;
            xy(2, 0) = xy(2, 0) * 0.470142064105115; xy(2, 1) = xy(2, 1) * 0.470142064105115;
            xy(3, 0) = xy(3, 0) * 0.470142064105115; xy(3, 1) = xy(3, 1) * 0.059715871789770;
            xy(4, 0) = xy(4, 0) * 0.797426985353087; xy(4, 1) = xy(4, 1) * 0.101286507323456;
            xy(5, 0) = xy(5, 0) * 0.101286507323456; xy(5, 1) = xy(5, 1) * 0.101286507323456;
            xy(6, 0) = xy(6, 0) * 0.101286507323456; xy(6, 1) = xy(6, 1) * 0.797426985353087;
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;
        case 3: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;
        }
        break;
    case 2:
        switch (q)
        {
        case 1: // Order 5 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.059715871789770; xy(1, 1) = xy(1, 1) * 0.470142064105115;
            xy(2, 0) = xy(2, 0) * 0.470142064105115; xy(2, 1) = xy(2, 1) * 0.470142064105115;
            xy(3, 0) = xy(3, 0) * 0.470142064105115; xy(3, 1) = xy(3, 1) * 0.059715871789770;
            xy(4, 0) = xy(4, 0) * 0.797426985353087; xy(4, 1) = xy(4, 1) * 0.101286507323456;
            xy(5, 0) = xy(5, 0) * 0.101286507323456; xy(5, 1) = xy(5, 1) * 0.101286507323456;
            xy(6, 0) = xy(6, 0) * 0.101286507323456; xy(6, 1) = xy(6, 1) * 0.797426985353087;
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;
        case 2: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;
        case 3: // Order 9 Dunavant Points
            xy(0, 0) = 0.333333333333333 * xy(0, 0); xy(0, 1) = 0.333333333333333 * xy(0, 1);
            xy(1, 0) = 0.020634961602525 * xy(1, 0); xy(1, 1) = 0.489682519198738 * xy(1, 1);
            xy(2, 0) = 0.489682519198738 * xy(2, 0); xy(2, 1) = 0.489682519198738 * xy(2, 1);
            xy(3, 0) = 0.489682519198738 * xy(3, 0); xy(3, 1) = 0.020634961602525 * xy(3, 1);
            xy(4, 0) = 0.125820817014127 * xy(4, 0); xy(4, 1) = 0.437089591492937 * xy(4, 1);
            xy(5, 0) = 0.437089591492937 * xy(5, 0); xy(5, 1) = 0.437089591492937 * xy(5, 1);
            xy(6, 0) = 0.437089591492937 * xy(6, 0); xy(6, 1) = 0.125820817014127 * xy(6, 1);
            xy(7, 0) = 0.623592928761935 * xy(7, 0); xy(7, 1) = 0.188203535619033 * xy(7, 1);
            xy(8, 0) = 0.188203535619033 * xy(8, 0); xy(8, 1) = 0.188203535619033 * xy(8, 1);
            xy(9, 0) = 0.188203535619033 * xy(9, 0); xy(9, 1) = 0.623592928761935 * xy(9, 1);
            xy(10, 0) = 0.910540973211095 * xy(10, 0); xy(10, 1) = 0.044729513394453 * xy(10, 1);
            xy(11, 0) = 0.044729513394453 * xy(11, 0); xy(11, 1) = 0.044729513394453 * xy(11, 1);
            xy(12, 0) = 0.044729513394453 * xy(12, 0); xy(12, 1) = 0.910540973211095 * xy(12, 1);
            xy(13, 0) = 0.036838412054736 * xy(13, 0); xy(13, 1) = 0.221962989160766 * xy(13, 1);
            xy(14, 0) = 0.221962989160766 * xy(14, 0); xy(14, 1) = 0.741198598784498 * xy(14, 1);
            xy(15, 0) = 0.741198598784498 * xy(15, 0); xy(15, 1) = 0.036838412054736 * xy(15, 1);
            xy(16, 0) = 0.221962989160766 * xy(16, 0); xy(16, 1) = 0.036838412054736 * xy(16, 1);
            xy(17, 0) = 0.741198598784498 * xy(17, 0); xy(17, 1) = 0.221962989160766 * xy(17, 1);
            xy(18, 0) = 0.036838412054736 * xy(18, 0); xy(18, 1) = 0.741198598784498 * xy(18, 1);
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;
        }
        break;
    case 3:
        switch (q)
        {
        case 1: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;
        case 2: // Order 9 Dunavant Points
            xy(0, 0) = 0.333333333333333 * xy(0, 0); xy(0, 1) = 0.333333333333333 * xy(0, 1);
            xy(1, 0) = 0.020634961602525 * xy(1, 0); xy(1, 1) = 0.489682519198738 * xy(1, 1);
            xy(2, 0) = 0.489682519198738 * xy(2, 0); xy(2, 1) = 0.489682519198738 * xy(2, 1);
            xy(3, 0) = 0.489682519198738 * xy(3, 0); xy(3, 1) = 0.020634961602525 * xy(3, 1);
            xy(4, 0) = 0.125820817014127 * xy(4, 0); xy(4, 1) = 0.437089591492937 * xy(4, 1);
            xy(5, 0) = 0.437089591492937 * xy(5, 0); xy(5, 1) = 0.437089591492937 * xy(5, 1);
            xy(6, 0) = 0.437089591492937 * xy(6, 0); xy(6, 1) = 0.125820817014127 * xy(6, 1);
            xy(7, 0) = 0.623592928761935 * xy(7, 0); xy(7, 1) = 0.188203535619033 * xy(7, 1);
            xy(8, 0) = 0.188203535619033 * xy(8, 0); xy(8, 1) = 0.188203535619033 * xy(8, 1);
            xy(9, 0) = 0.188203535619033 * xy(9, 0); xy(9, 1) = 0.623592928761935 * xy(9, 1);
            xy(10, 0) = 0.910540973211095 * xy(10, 0); xy(10, 1) = 0.044729513394453 * xy(10, 1);
            xy(11, 0) = 0.044729513394453 * xy(11, 0); xy(11, 1) = 0.044729513394453 * xy(11, 1);
            xy(12, 0) = 0.044729513394453 * xy(12, 0); xy(12, 1) = 0.910540973211095 * xy(12, 1);
            xy(13, 0) = 0.036838412054736 * xy(13, 0); xy(13, 1) = 0.221962989160766 * xy(13, 1);
            xy(14, 0) = 0.221962989160766 * xy(14, 0); xy(14, 1) = 0.741198598784498 * xy(14, 1);
            xy(15, 0) = 0.741198598784498 * xy(15, 0); xy(15, 1) = 0.036838412054736 * xy(15, 1);
            xy(16, 0) = 0.221962989160766 * xy(16, 0); xy(16, 1) = 0.036838412054736 * xy(16, 1);
            xy(17, 0) = 0.741198598784498 * xy(17, 0); xy(17, 1) = 0.221962989160766 * xy(17, 1);
            xy(18, 0) = 0.036838412054736 * xy(18, 0); xy(18, 1) = 0.741198598784498 * xy(18, 1);
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;
        case 3: // Order 12 Dunavant Points
            xy(0, 0) = 0.023565220452390 * xy(0, 0); xy(0, 1) = 0.488217389773805 * xy(0, 1);
            xy(1, 0) = 0.488217389773805 * xy(1, 0); xy(1, 1) = 0.488217389773805 * xy(1, 1);
            xy(2, 0) = 0.488217389773805 * xy(2, 0); xy(2, 1) = 0.023565220452390 * xy(2, 1);
            xy(3, 0) = 0.120551215411079 * xy(3, 0); xy(3, 1) = 0.439724392294460 * xy(3, 1);
            xy(4, 0) = 0.439724392294460 * xy(4, 0); xy(4, 1) = 0.439724392294460 * xy(4, 1);
            xy(5, 0) = 0.439724392294460 * xy(5, 0); xy(5, 1) = 0.120551215411079 * xy(5, 1);
            xy(6, 0) = 0.457579229975768 * xy(6, 0); xy(6, 1) = 0.271210385012116 * xy(6, 1);
            xy(7, 0) = 0.271210385012116 * xy(7, 0); xy(7, 1) = 0.271210385012116 * xy(7, 1);
            xy(8, 0) = 0.271210385012116 * xy(8, 0); xy(8, 1) = 0.457579229975768 * xy(8, 1);
            xy(9, 0) = 0.744847708916828 * xy(9, 0); xy(9, 1) = 0.127576145541586 * xy(9, 1);
            xy(10, 0) = 0.127576145541586 * xy(10, 0); xy(10, 1) = 0.127576145541586 * xy(10, 1);
            xy(11, 0) = 0.127576145541586 * xy(11, 0); xy(11, 1) = 0.744847708916828 * xy(11, 1);
            xy(12, 0) = 0.957365299093579 * xy(12, 0); xy(12, 1) = 0.021317350453210 * xy(12, 1);
            xy(13, 0) = 0.021317350453210 * xy(13, 0); xy(13, 1) = 0.021317350453210 * xy(13, 1);
            xy(14, 0) = 0.021317350453210 * xy(14, 0); xy(14, 1) = 0.957365299093579 * xy(14, 1);
            xy(15, 0) = 0.115343494534698 * xy(15, 0); xy(15, 1) = 0.275713269685514 * xy(15, 1);
            xy(16, 0) = 0.275713269685514 * xy(16, 0); xy(16, 1) = 0.608943235779788 * xy(16, 1);
            xy(17, 0) = 0.608943235779788 * xy(17, 0); xy(17, 1) = 0.115343494534698 * xy(17, 1);
            xy(18, 0) = 0.275713269685514 * xy(18, 0); xy(18, 1) = 0.115343494534698 * xy(18, 1);
            xy(19, 0) = 0.608943235779788 * xy(19, 0); xy(19, 1) = 0.275713269685514 * xy(19, 1);
            xy(20, 0) = 0.115343494534698 * xy(20, 0); xy(20, 1) = 0.608943235779788 * xy(20, 1);
            xy(21, 0) = 0.022838332222257 * xy(21, 0); xy(21, 1) = 0.281325580989940 * xy(21, 1);
            xy(22, 0) = 0.281325580989940 * xy(22, 0); xy(22, 1) = 0.695836086787803 * xy(22, 1);
            xy(23, 0) = 0.695836086787803 * xy(23, 0); xy(23, 1) = 0.022838332222257 * xy(23, 1);
            xy(24, 0) = 0.281325580989940 * xy(24, 0); xy(24, 1) = 0.022838332222257 * xy(24, 1);
            xy(25, 0) = 0.695836086787803 * xy(25, 0); xy(25, 1) = 0.281325580989940 * xy(25, 1);
            xy(26, 0) = 0.022838332222257 * xy(26, 0); xy(26, 1) = 0.695836086787803 * xy(26, 1);
            xy(27, 0) = 0.025734050548330 * xy(27, 0); xy(27, 1) = 0.116251915907597 * xy(27, 1);
            xy(28, 0) = 0.116251915907597 * xy(28, 0); xy(28, 1) = 0.858014033544073 * xy(28, 1);
            xy(29, 0) = 0.858014033544073 * xy(29, 0); xy(29, 1) = 0.025734050548330 * xy(29, 1);
            xy(30, 0) = 0.116251915907597 * xy(30, 0); xy(30, 1) = 0.025734050548330 * xy(30, 1);
            xy(31, 0) = 0.858014033544073 * xy(31, 0); xy(31, 1) = 0.116251915907597 * xy(31, 1);
            xy(32, 0) = 0.025734050548330 * xy(32, 0); xy(32, 1) = 0.858014033544073 * xy(32, 1);
            for (int i = 0; i < np(p, q - 1); i++) {
                b_quad(all, i) = Basis(xy(i, all), p);
            }
            break;
        }
        break;
    default:
        cout << "Invalid Order \n";
        b_quad.isZero();
        break;
    }
    return b_quad;
}

MatrixXd BasisGradQuad(int p, int q) {
    int rank = (p + 1) * (p + 2) / 2;
    MatrixXi np(4, 3); np(0, 0) = 4; np(1, 0) = 4; np(2, 0) = 7; np(3, 0) = 13;
    np(0, 1) = 7; np(1, 1) = 7; np(2, 1) = 13; np(3, 1) = 19;
    np(0, 2) = 13; np(1, 2) = 13; np(2, 2) = 19; np(3, 2) = 33;
    MatrixXd bg_quad(rank, 2*np(p, q - 1));
    MatrixXd xy(np(p, q - 1), 2);
    for (int i = 0; i < np(p, q - 1); i++) {
        for (int j = 0; j < 2; j++) {
            xy(i, j) = 1;
        }
    }
    switch (p) {
    case 0: // arbitrary bc const. phi, so have taken same as Case 1  //
        switch (q)
        {
        case 1: // Order 3 Dunavant Points
            xy(0, 0) = xy(0, 0) / 3; xy(0, 1) = xy(0, 1) / 3;
            xy(1, 0) = 3 * xy(1, 0) / 5; xy(1, 1) = xy(1, 1) / 5;
            xy(2, 0) = xy(2, 0) / 5; xy(2, 1) = xy(2, 1) / 5;
            xy(3, 0) = xy(3, 0) / 5; xy(3, 1) = 3 * xy(3, 1) / 5;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;

        case 2: // Order 5 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.059715871789770; xy(1, 1) = xy(1, 1) * 0.470142064105115;
            xy(2, 0) = xy(2, 0) * 0.470142064105115; xy(2, 1) = xy(2, 1) * 0.470142064105115;
            xy(3, 0) = xy(3, 0) * 0.470142064105115; xy(3, 1) = xy(3, 1) * 0.059715871789770;
            xy(4, 0) = xy(4, 0) * 0.797426985353087; xy(4, 1) = xy(4, 1) * 0.101286507323456;
            xy(5, 0) = xy(5, 0) * 0.101286507323456; xy(5, 1) = xy(5, 1) * 0.101286507323456;
            xy(6, 0) = xy(6, 0) * 0.101286507323456; xy(6, 1) = xy(6, 1) * 0.797426985353087;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;
        case 3: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;
        }
        break;
    case 1:
        switch (q)
        {
        case 1: // Order 3 Dunavant Points
            xy(0, 0) = xy(0, 0) / 3; xy(0, 1) = xy(0, 1) / 3;
            xy(1, 0) = 3 * xy(1, 0) / 5; xy(1, 1) = xy(1, 1) / 5;
            xy(2, 0) = xy(2, 0) / 5; xy(2, 1) = xy(2, 1) / 5;
            xy(3, 0) = xy(3, 0) / 5; xy(3, 1) = 3 * xy(3, 1) / 5;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;
        case 2: // Order 5 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.059715871789770; xy(1, 1) = xy(1, 1) * 0.470142064105115;
            xy(2, 0) = xy(2, 0) * 0.470142064105115; xy(2, 1) = xy(2, 1) * 0.470142064105115;
            xy(3, 0) = xy(3, 0) * 0.470142064105115; xy(3, 1) = xy(3, 1) * 0.059715871789770;
            xy(4, 0) = xy(4, 0) * 0.797426985353087; xy(4, 1) = xy(4, 1) * 0.101286507323456;
            xy(5, 0) = xy(5, 0) * 0.101286507323456; xy(5, 1) = xy(5, 1) * 0.101286507323456;
            xy(6, 0) = xy(6, 0) * 0.101286507323456; xy(6, 1) = xy(6, 1) * 0.797426985353087;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;
        case 3: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;
        }
        break;
    case 2:
        switch (q)
        {
        case 1: // Order 5 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.059715871789770; xy(1, 1) = xy(1, 1) * 0.470142064105115;
            xy(2, 0) = xy(2, 0) * 0.470142064105115; xy(2, 1) = xy(2, 1) * 0.470142064105115;
            xy(3, 0) = xy(3, 0) * 0.470142064105115; xy(3, 1) = xy(3, 1) * 0.059715871789770;
            xy(4, 0) = xy(4, 0) * 0.797426985353087; xy(4, 1) = xy(4, 1) * 0.101286507323456;
            xy(5, 0) = xy(5, 0) * 0.101286507323456; xy(5, 1) = xy(5, 1) * 0.101286507323456;
            xy(6, 0) = xy(6, 0) * 0.101286507323456; xy(6, 1) = xy(6, 1) * 0.797426985353087;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;
        case 2: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;
        case 3: // Order 9 Dunavant Points
            xy(0, 0) = 0.333333333333333 * xy(0, 0); xy(0, 1) = 0.333333333333333 * xy(0, 1);
            xy(1, 0) = 0.020634961602525 * xy(1, 0); xy(1, 1) = 0.489682519198738 * xy(1, 1);
            xy(2, 0) = 0.489682519198738 * xy(2, 0); xy(2, 1) = 0.489682519198738 * xy(2, 1);
            xy(3, 0) = 0.489682519198738 * xy(3, 0); xy(3, 1) = 0.020634961602525 * xy(3, 1);
            xy(4, 0) = 0.125820817014127 * xy(4, 0); xy(4, 1) = 0.437089591492937 * xy(4, 1);
            xy(5, 0) = 0.437089591492937 * xy(5, 0); xy(5, 1) = 0.437089591492937 * xy(5, 1);
            xy(6, 0) = 0.437089591492937 * xy(6, 0); xy(6, 1) = 0.125820817014127 * xy(6, 1);
            xy(7, 0) = 0.623592928761935 * xy(7, 0); xy(7, 1) = 0.188203535619033 * xy(7, 1);
            xy(8, 0) = 0.188203535619033 * xy(8, 0); xy(8, 1) = 0.188203535619033 * xy(8, 1);
            xy(9, 0) = 0.188203535619033 * xy(9, 0); xy(9, 1) = 0.623592928761935 * xy(9, 1);
            xy(10, 0) = 0.910540973211095 * xy(10, 0); xy(10, 1) = 0.044729513394453 * xy(10, 1);
            xy(11, 0) = 0.044729513394453 * xy(11, 0); xy(11, 1) = 0.044729513394453 * xy(11, 1);
            xy(12, 0) = 0.044729513394453 * xy(12, 0); xy(12, 1) = 0.910540973211095 * xy(12, 1);
            xy(13, 0) = 0.036838412054736 * xy(13, 0); xy(13, 1) = 0.221962989160766 * xy(13, 1);
            xy(14, 0) = 0.221962989160766 * xy(14, 0); xy(14, 1) = 0.741198598784498 * xy(14, 1);
            xy(15, 0) = 0.741198598784498 * xy(15, 0); xy(15, 1) = 0.036838412054736 * xy(15, 1);
            xy(16, 0) = 0.221962989160766 * xy(16, 0); xy(16, 1) = 0.036838412054736 * xy(16, 1);
            xy(17, 0) = 0.741198598784498 * xy(17, 0); xy(17, 1) = 0.221962989160766 * xy(17, 1);
            xy(18, 0) = 0.036838412054736 * xy(18, 0); xy(18, 1) = 0.741198598784498 * xy(18, 1);
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;
        }
        break;
    case 3:
        switch (q)
        {
        case 1: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;
        case 2: // Order 9 Dunavant Points
            xy(0, 0) = 0.333333333333333 * xy(0, 0); xy(0, 1) = 0.333333333333333 * xy(0, 1);
            xy(1, 0) = 0.020634961602525 * xy(1, 0); xy(1, 1) = 0.489682519198738 * xy(1, 1);
            xy(2, 0) = 0.489682519198738 * xy(2, 0); xy(2, 1) = 0.489682519198738 * xy(2, 1);
            xy(3, 0) = 0.489682519198738 * xy(3, 0); xy(3, 1) = 0.020634961602525 * xy(3, 1);
            xy(4, 0) = 0.125820817014127 * xy(4, 0); xy(4, 1) = 0.437089591492937 * xy(4, 1);
            xy(5, 0) = 0.437089591492937 * xy(5, 0); xy(5, 1) = 0.437089591492937 * xy(5, 1);
            xy(6, 0) = 0.437089591492937 * xy(6, 0); xy(6, 1) = 0.125820817014127 * xy(6, 1);
            xy(7, 0) = 0.623592928761935 * xy(7, 0); xy(7, 1) = 0.188203535619033 * xy(7, 1);
            xy(8, 0) = 0.188203535619033 * xy(8, 0); xy(8, 1) = 0.188203535619033 * xy(8, 1);
            xy(9, 0) = 0.188203535619033 * xy(9, 0); xy(9, 1) = 0.623592928761935 * xy(9, 1);
            xy(10, 0) = 0.910540973211095 * xy(10, 0); xy(10, 1) = 0.044729513394453 * xy(10, 1);
            xy(11, 0) = 0.044729513394453 * xy(11, 0); xy(11, 1) = 0.044729513394453 * xy(11, 1);
            xy(12, 0) = 0.044729513394453 * xy(12, 0); xy(12, 1) = 0.910540973211095 * xy(12, 1);
            xy(13, 0) = 0.036838412054736 * xy(13, 0); xy(13, 1) = 0.221962989160766 * xy(13, 1);
            xy(14, 0) = 0.221962989160766 * xy(14, 0); xy(14, 1) = 0.741198598784498 * xy(14, 1);
            xy(15, 0) = 0.741198598784498 * xy(15, 0); xy(15, 1) = 0.036838412054736 * xy(15, 1);
            xy(16, 0) = 0.221962989160766 * xy(16, 0); xy(16, 1) = 0.036838412054736 * xy(16, 1);
            xy(17, 0) = 0.741198598784498 * xy(17, 0); xy(17, 1) = 0.221962989160766 * xy(17, 1);
            xy(18, 0) = 0.036838412054736 * xy(18, 0); xy(18, 1) = 0.741198598784498 * xy(18, 1);
            for (int i = 0; i < np(p, q - 1); i++) {
                 bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;
        case 3: // Order 12 Dunavant Points
            xy(0, 0) = 0.023565220452390 * xy(0, 0); xy(0, 1) = 0.488217389773805 * xy(0, 1);
            xy(1, 0) = 0.488217389773805 * xy(1, 0); xy(1, 1) = 0.488217389773805 * xy(1, 1);
            xy(2, 0) = 0.488217389773805 * xy(2, 0); xy(2, 1) = 0.023565220452390 * xy(2, 1);
            xy(3, 0) = 0.120551215411079 * xy(3, 0); xy(3, 1) = 0.439724392294460 * xy(3, 1);
            xy(4, 0) = 0.439724392294460 * xy(4, 0); xy(4, 1) = 0.439724392294460 * xy(4, 1);
            xy(5, 0) = 0.439724392294460 * xy(5, 0); xy(5, 1) = 0.120551215411079 * xy(5, 1);
            xy(6, 0) = 0.457579229975768 * xy(6, 0); xy(6, 1) = 0.271210385012116 * xy(6, 1);
            xy(7, 0) = 0.271210385012116 * xy(7, 0); xy(7, 1) = 0.271210385012116 * xy(7, 1);
            xy(8, 0) = 0.271210385012116 * xy(8, 0); xy(8, 1) = 0.457579229975768 * xy(8, 1);
            xy(9, 0) = 0.744847708916828 * xy(9, 0); xy(9, 1) = 0.127576145541586 * xy(9, 1);
            xy(10, 0) = 0.127576145541586 * xy(10, 0); xy(10, 1) = 0.127576145541586 * xy(10, 1);
            xy(11, 0) = 0.127576145541586 * xy(11, 0); xy(11, 1) = 0.744847708916828 * xy(11, 1);
            xy(12, 0) = 0.957365299093579 * xy(12, 0); xy(12, 1) = 0.021317350453210 * xy(12, 1);
            xy(13, 0) = 0.021317350453210 * xy(13, 0); xy(13, 1) = 0.021317350453210 * xy(13, 1);
            xy(14, 0) = 0.021317350453210 * xy(14, 0); xy(14, 1) = 0.957365299093579 * xy(14, 1);
            xy(15, 0) = 0.115343494534698 * xy(15, 0); xy(15, 1) = 0.275713269685514 * xy(15, 1);
            xy(16, 0) = 0.275713269685514 * xy(16, 0); xy(16, 1) = 0.608943235779788 * xy(16, 1);
            xy(17, 0) = 0.608943235779788 * xy(17, 0); xy(17, 1) = 0.115343494534698 * xy(17, 1);
            xy(18, 0) = 0.275713269685514 * xy(18, 0); xy(18, 1) = 0.115343494534698 * xy(18, 1);
            xy(19, 0) = 0.608943235779788 * xy(19, 0); xy(19, 1) = 0.275713269685514 * xy(19, 1);
            xy(20, 0) = 0.115343494534698 * xy(20, 0); xy(20, 1) = 0.608943235779788 * xy(20, 1);
            xy(21, 0) = 0.022838332222257 * xy(21, 0); xy(21, 1) = 0.281325580989940 * xy(21, 1);
            xy(22, 0) = 0.281325580989940 * xy(22, 0); xy(22, 1) = 0.695836086787803 * xy(22, 1);
            xy(23, 0) = 0.695836086787803 * xy(23, 0); xy(23, 1) = 0.022838332222257 * xy(23, 1);
            xy(24, 0) = 0.281325580989940 * xy(24, 0); xy(24, 1) = 0.022838332222257 * xy(24, 1);
            xy(25, 0) = 0.695836086787803 * xy(25, 0); xy(25, 1) = 0.281325580989940 * xy(25, 1);
            xy(26, 0) = 0.022838332222257 * xy(26, 0); xy(26, 1) = 0.695836086787803 * xy(26, 1);
            xy(27, 0) = 0.025734050548330 * xy(27, 0); xy(27, 1) = 0.116251915907597 * xy(27, 1);
            xy(28, 0) = 0.116251915907597 * xy(28, 0); xy(28, 1) = 0.858014033544073 * xy(28, 1);
            xy(29, 0) = 0.858014033544073 * xy(29, 0); xy(29, 1) = 0.025734050548330 * xy(29, 1);
            xy(30, 0) = 0.116251915907597 * xy(30, 0); xy(30, 1) = 0.025734050548330 * xy(30, 1);
            xy(31, 0) = 0.858014033544073 * xy(31, 0); xy(31, 1) = 0.116251915907597 * xy(31, 1);
            xy(32, 0) = 0.025734050548330 * xy(32, 0); xy(32, 1) = 0.858014033544073 * xy(32, 1);
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), p);
            }
            break;
        }
        break;
    default:
        cout << "Invalid Order \n";
        bg_quad.isZero();
        break;
    }
    return bg_quad;
}

MatrixXd BasisGradQuadJac(int p, int q) {
    int rank = (q + 1) * (q + 2) / 2;
    MatrixXi np(4, 3); np(0, 0) = 4; np(1, 0) = 4; np(2, 0) = 7; np(3, 0) = 13;
    np(0, 1) = 7; np(1, 1) = 7; np(2, 1) = 13; np(3, 1) = 19;
    np(0, 2) = 13; np(1, 2) = 13; np(2, 2) = 19; np(3, 2) = 33;
    MatrixXd bg_quad(rank, 2*np(p, q - 1));
    MatrixXd xy(np(p, q - 1), 2);
    for (int i = 0; i < np(p, q - 1); i++) {
        for (int j = 0; j < 2; j++) {
            xy(i, j) = 1;
        }
    }
    switch (p) {
    case 0: // arbitrary bc const. phi, so have taken same as Case 1  //
        switch (q)
        {
        case 1: // Order 3 Dunavant Points
            xy(0, 0) = xy(0, 0) / 3; xy(0, 1) = xy(0, 1) / 3;
            xy(1, 0) = 3 * xy(1, 0) / 5; xy(1, 1) = xy(1, 1) / 5;
            xy(2, 0) = xy(2, 0) / 5; xy(2, 1) = xy(2, 1) / 5;
            xy(3, 0) = xy(3, 0) / 5; xy(3, 1) = 3 * xy(3, 1) / 5;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;

        case 2: // Order 5 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.059715871789770; xy(1, 1) = xy(1, 1) * 0.470142064105115;
            xy(2, 0) = xy(2, 0) * 0.470142064105115; xy(2, 1) = xy(2, 1) * 0.470142064105115;
            xy(3, 0) = xy(3, 0) * 0.470142064105115; xy(3, 1) = xy(3, 1) * 0.059715871789770;
            xy(4, 0) = xy(4, 0) * 0.797426985353087; xy(4, 1) = xy(4, 1) * 0.101286507323456;
            xy(5, 0) = xy(5, 0) * 0.101286507323456; xy(5, 1) = xy(5, 1) * 0.101286507323456;
            xy(6, 0) = xy(6, 0) * 0.101286507323456; xy(6, 1) = xy(6, 1) * 0.797426985353087;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;
        case 3: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;
        }
        break;
    case 1:
        switch (q)
        {
        case 1: // Order 3 Dunavant Points
            xy(0, 0) = xy(0, 0) / 3; xy(0, 1) = xy(0, 1) / 3;
            xy(1, 0) = 3 * xy(1, 0) / 5; xy(1, 1) = xy(1, 1) / 5;
            xy(2, 0) = xy(2, 0) / 5; xy(2, 1) = xy(2, 1) / 5;
            xy(3, 0) = xy(3, 0) / 5; xy(3, 1) = 3 * xy(3, 1) / 5;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;
        case 2: // Order 5 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.059715871789770; xy(1, 1) = xy(1, 1) * 0.470142064105115;
            xy(2, 0) = xy(2, 0) * 0.470142064105115; xy(2, 1) = xy(2, 1) * 0.470142064105115;
            xy(3, 0) = xy(3, 0) * 0.470142064105115; xy(3, 1) = xy(3, 1) * 0.059715871789770;
            xy(4, 0) = xy(4, 0) * 0.797426985353087; xy(4, 1) = xy(4, 1) * 0.101286507323456;
            xy(5, 0) = xy(5, 0) * 0.101286507323456; xy(5, 1) = xy(5, 1) * 0.101286507323456;
            xy(6, 0) = xy(6, 0) * 0.101286507323456; xy(6, 1) = xy(6, 1) * 0.797426985353087;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;
        case 3: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;
        }
        break;
    case 2:
        switch (q)
        {
        case 1: // Order 5 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.059715871789770; xy(1, 1) = xy(1, 1) * 0.470142064105115;
            xy(2, 0) = xy(2, 0) * 0.470142064105115; xy(2, 1) = xy(2, 1) * 0.470142064105115;
            xy(3, 0) = xy(3, 0) * 0.470142064105115; xy(3, 1) = xy(3, 1) * 0.059715871789770;
            xy(4, 0) = xy(4, 0) * 0.797426985353087; xy(4, 1) = xy(4, 1) * 0.101286507323456;
            xy(5, 0) = xy(5, 0) * 0.101286507323456; xy(5, 1) = xy(5, 1) * 0.101286507323456;
            xy(6, 0) = xy(6, 0) * 0.101286507323456; xy(6, 1) = xy(6, 1) * 0.797426985353087;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;
        case 2: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;
        case 3: // Order 9 Dunavant Points
            xy(0, 0) = 0.333333333333333 * xy(0, 0); xy(0, 1) = 0.333333333333333 * xy(0, 1);
            xy(1, 0) = 0.020634961602525 * xy(1, 0); xy(1, 1) = 0.489682519198738 * xy(1, 1);
            xy(2, 0) = 0.489682519198738 * xy(2, 0); xy(2, 1) = 0.489682519198738 * xy(2, 1);
            xy(3, 0) = 0.489682519198738 * xy(3, 0); xy(3, 1) = 0.020634961602525 * xy(3, 1);
            xy(4, 0) = 0.125820817014127 * xy(4, 0); xy(4, 1) = 0.437089591492937 * xy(4, 1);
            xy(5, 0) = 0.437089591492937 * xy(5, 0); xy(5, 1) = 0.437089591492937 * xy(5, 1);
            xy(6, 0) = 0.437089591492937 * xy(6, 0); xy(6, 1) = 0.125820817014127 * xy(6, 1);
            xy(7, 0) = 0.623592928761935 * xy(7, 0); xy(7, 1) = 0.188203535619033 * xy(7, 1);
            xy(8, 0) = 0.188203535619033 * xy(8, 0); xy(8, 1) = 0.188203535619033 * xy(8, 1);
            xy(9, 0) = 0.188203535619033 * xy(9, 0); xy(9, 1) = 0.623592928761935 * xy(9, 1);
            xy(10, 0) = 0.910540973211095 * xy(10, 0); xy(10, 1) = 0.044729513394453 * xy(10, 1);
            xy(11, 0) = 0.044729513394453 * xy(11, 0); xy(11, 1) = 0.044729513394453 * xy(11, 1);
            xy(12, 0) = 0.044729513394453 * xy(12, 0); xy(12, 1) = 0.910540973211095 * xy(12, 1);
            xy(13, 0) = 0.036838412054736 * xy(13, 0); xy(13, 1) = 0.221962989160766 * xy(13, 1);
            xy(14, 0) = 0.221962989160766 * xy(14, 0); xy(14, 1) = 0.741198598784498 * xy(14, 1);
            xy(15, 0) = 0.741198598784498 * xy(15, 0); xy(15, 1) = 0.036838412054736 * xy(15, 1);
            xy(16, 0) = 0.221962989160766 * xy(16, 0); xy(16, 1) = 0.036838412054736 * xy(16, 1);
            xy(17, 0) = 0.741198598784498 * xy(17, 0); xy(17, 1) = 0.221962989160766 * xy(17, 1);
            xy(18, 0) = 0.036838412054736 * xy(18, 0); xy(18, 1) = 0.741198598784498 * xy(18, 1);
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;
        }
        break;
    case 3:
        switch (q)
        {
        case 1: // Order 7 Dunavant Points
            xy(0, 0) = xy(0, 0) * 0.333333333333333; xy(0, 1) = xy(0, 1) * 0.333333333333333;
            xy(1, 0) = xy(1, 0) * 0.479308067841920; xy(1, 1) = xy(1, 1) * 0.260345966079040;
            xy(2, 0) = xy(2, 0) * 0.260345966079040; xy(2, 1) = xy(2, 1) * 0.260345966079040;
            xy(3, 0) = xy(3, 0) * 0.260345966079040; xy(3, 1) = xy(3, 1) * 0.479308067841920;
            xy(4, 0) = xy(4, 0) * 0.869739794195568; xy(4, 1) = xy(4, 1) * 0.065130102902216;
            xy(5, 0) = xy(5, 0) * 0.065130102902216; xy(5, 1) = xy(5, 1) * 0.065130102902216;
            xy(6, 0) = xy(6, 0) * 0.065130102902216; xy(6, 1) = xy(6, 1) * 0.869739794195568;
            xy(7, 0) = xy(7, 0) * 0.048690315425316; xy(7, 1) = xy(7, 1) * 0.312865496004874;
            xy(8, 0) = xy(8, 0) * 0.312865496004874; xy(8, 1) = xy(8, 1) * 0.638444188569810;
            xy(9, 0) = xy(9, 0) * 0.638444188569810; xy(9, 1) = xy(9, 1) * 0.048690315425316;
            xy(10, 0) = xy(10, 0) * 0.312865496004874; xy(10, 1) = xy(10, 1) * 0.048690315425316;
            xy(11, 0) = xy(11, 0) * 0.638444188569810; xy(11, 1) = xy(11, 1) * 0.312865496004874;
            xy(12, 0) = xy(12, 0) * 0.048690315425316; xy(12, 1) = xy(12, 1) * 0.638444188569810;
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;
        case 2: // Order 9 Dunavant Points
            xy(0, 0) = 0.333333333333333 * xy(0, 0); xy(0, 1) = 0.333333333333333 * xy(0, 1);
            xy(1, 0) = 0.020634961602525 * xy(1, 0); xy(1, 1) = 0.489682519198738 * xy(1, 1);
            xy(2, 0) = 0.489682519198738 * xy(2, 0); xy(2, 1) = 0.489682519198738 * xy(2, 1);
            xy(3, 0) = 0.489682519198738 * xy(3, 0); xy(3, 1) = 0.020634961602525 * xy(3, 1);
            xy(4, 0) = 0.125820817014127 * xy(4, 0); xy(4, 1) = 0.437089591492937 * xy(4, 1);
            xy(5, 0) = 0.437089591492937 * xy(5, 0); xy(5, 1) = 0.437089591492937 * xy(5, 1);
            xy(6, 0) = 0.437089591492937 * xy(6, 0); xy(6, 1) = 0.125820817014127 * xy(6, 1);
            xy(7, 0) = 0.623592928761935 * xy(7, 0); xy(7, 1) = 0.188203535619033 * xy(7, 1);
            xy(8, 0) = 0.188203535619033 * xy(8, 0); xy(8, 1) = 0.188203535619033 * xy(8, 1);
            xy(9, 0) = 0.188203535619033 * xy(9, 0); xy(9, 1) = 0.623592928761935 * xy(9, 1);
            xy(10, 0) = 0.910540973211095 * xy(10, 0); xy(10, 1) = 0.044729513394453 * xy(10, 1);
            xy(11, 0) = 0.044729513394453 * xy(11, 0); xy(11, 1) = 0.044729513394453 * xy(11, 1);
            xy(12, 0) = 0.044729513394453 * xy(12, 0); xy(12, 1) = 0.910540973211095 * xy(12, 1);
            xy(13, 0) = 0.036838412054736 * xy(13, 0); xy(13, 1) = 0.221962989160766 * xy(13, 1);
            xy(14, 0) = 0.221962989160766 * xy(14, 0); xy(14, 1) = 0.741198598784498 * xy(14, 1);
            xy(15, 0) = 0.741198598784498 * xy(15, 0); xy(15, 1) = 0.036838412054736 * xy(15, 1);
            xy(16, 0) = 0.221962989160766 * xy(16, 0); xy(16, 1) = 0.036838412054736 * xy(16, 1);
            xy(17, 0) = 0.741198598784498 * xy(17, 0); xy(17, 1) = 0.221962989160766 * xy(17, 1);
            xy(18, 0) = 0.036838412054736 * xy(18, 0); xy(18, 1) = 0.741198598784498 * xy(18, 1);
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;
        case 3: // Order 12 Dunavant Points
            xy(0, 0) = 0.023565220452390 * xy(0, 0); xy(0, 1) = 0.488217389773805 * xy(0, 1);
            xy(1, 0) = 0.488217389773805 * xy(1, 0); xy(1, 1) = 0.488217389773805 * xy(1, 1);
            xy(2, 0) = 0.488217389773805 * xy(2, 0); xy(2, 1) = 0.023565220452390 * xy(2, 1);
            xy(3, 0) = 0.120551215411079 * xy(3, 0); xy(3, 1) = 0.439724392294460 * xy(3, 1);
            xy(4, 0) = 0.439724392294460 * xy(4, 0); xy(4, 1) = 0.439724392294460 * xy(4, 1);
            xy(5, 0) = 0.439724392294460 * xy(5, 0); xy(5, 1) = 0.120551215411079 * xy(5, 1);
            xy(6, 0) = 0.457579229975768 * xy(6, 0); xy(6, 1) = 0.271210385012116 * xy(6, 1);
            xy(7, 0) = 0.271210385012116 * xy(7, 0); xy(7, 1) = 0.271210385012116 * xy(7, 1);
            xy(8, 0) = 0.271210385012116 * xy(8, 0); xy(8, 1) = 0.457579229975768 * xy(8, 1);
            xy(9, 0) = 0.744847708916828 * xy(9, 0); xy(9, 1) = 0.127576145541586 * xy(9, 1);
            xy(10, 0) = 0.127576145541586 * xy(10, 0); xy(10, 1) = 0.127576145541586 * xy(10, 1);
            xy(11, 0) = 0.127576145541586 * xy(11, 0); xy(11, 1) = 0.744847708916828 * xy(11, 1);
            xy(12, 0) = 0.957365299093579 * xy(12, 0); xy(12, 1) = 0.021317350453210 * xy(12, 1);
            xy(13, 0) = 0.021317350453210 * xy(13, 0); xy(13, 1) = 0.021317350453210 * xy(13, 1);
            xy(14, 0) = 0.021317350453210 * xy(14, 0); xy(14, 1) = 0.957365299093579 * xy(14, 1);
            xy(15, 0) = 0.115343494534698 * xy(15, 0); xy(15, 1) = 0.275713269685514 * xy(15, 1);
            xy(16, 0) = 0.275713269685514 * xy(16, 0); xy(16, 1) = 0.608943235779788 * xy(16, 1);
            xy(17, 0) = 0.608943235779788 * xy(17, 0); xy(17, 1) = 0.115343494534698 * xy(17, 1);
            xy(18, 0) = 0.275713269685514 * xy(18, 0); xy(18, 1) = 0.115343494534698 * xy(18, 1);
            xy(19, 0) = 0.608943235779788 * xy(19, 0); xy(19, 1) = 0.275713269685514 * xy(19, 1);
            xy(20, 0) = 0.115343494534698 * xy(20, 0); xy(20, 1) = 0.608943235779788 * xy(20, 1);
            xy(21, 0) = 0.022838332222257 * xy(21, 0); xy(21, 1) = 0.281325580989940 * xy(21, 1);
            xy(22, 0) = 0.281325580989940 * xy(22, 0); xy(22, 1) = 0.695836086787803 * xy(22, 1);
            xy(23, 0) = 0.695836086787803 * xy(23, 0); xy(23, 1) = 0.022838332222257 * xy(23, 1);
            xy(24, 0) = 0.281325580989940 * xy(24, 0); xy(24, 1) = 0.022838332222257 * xy(24, 1);
            xy(25, 0) = 0.695836086787803 * xy(25, 0); xy(25, 1) = 0.281325580989940 * xy(25, 1);
            xy(26, 0) = 0.022838332222257 * xy(26, 0); xy(26, 1) = 0.695836086787803 * xy(26, 1);
            xy(27, 0) = 0.025734050548330 * xy(27, 0); xy(27, 1) = 0.116251915907597 * xy(27, 1);
            xy(28, 0) = 0.116251915907597 * xy(28, 0); xy(28, 1) = 0.858014033544073 * xy(28, 1);
            xy(29, 0) = 0.858014033544073 * xy(29, 0); xy(29, 1) = 0.025734050548330 * xy(29, 1);
            xy(30, 0) = 0.116251915907597 * xy(30, 0); xy(30, 1) = 0.025734050548330 * xy(30, 1);
            xy(31, 0) = 0.858014033544073 * xy(31, 0); xy(31, 1) = 0.116251915907597 * xy(31, 1);
            xy(32, 0) = 0.025734050548330 * xy(32, 0); xy(32, 1) = 0.858014033544073 * xy(32, 1);
            for (int i = 0; i < np(p, q - 1); i++) {
                bg_quad(all,{2*i,2*i+1}) = BasisGrad(xy(i, all), q);
            }
            break;
        }
        break;
    default:
        cout << "Invalid Order \n";
        bg_quad.isZero();
        break;
    }
    return bg_quad;
}

MatrixXd Quad(int p, int q) {
    int rank = (p + 1) * (p + 2) / 2;
    MatrixXi np(4, 3); np(0, 0) = 4; np(1, 0) = 4; np(2, 0) = 7; np(3, 0) = 13;
    np(0, 1) = 7; np(1, 1) = 7; np(2, 1) = 13; np(3, 1) = 19;
    np(0, 2) = 13; np(1, 2) = 13; np(2, 2) = 19; np(3, 2) = 33;
    MatrixXd w(1, np(p, q - 1));
    switch (p) {
    case 0:
        switch (q)
        {
        case 1: // Order 3 Dunavant Points
            w(0, 0) = -0.281250000000000;
            w(0, 1) = 0.260416666666667; w(0, 2) = 0.260416666666667; w(0, 3) = 0.260416666666667;
            break;

        case 2: // Order 5 Dunavant Points
            w(0, 0) = 0.112500000000000; w(0, 1) = 0.066197076394253; w(0, 2) = 0.066197076394253;
            w(0, 3) = 0.066197076394253; w(0, 4) = 0.062969590272414; w(0, 5) = 0.062969590272414; w(0, 6) = 0.062969590272414;
            break;

        case 3: // Order 7 Dunavant Points
            w(0, 0) = -0.074785022233841;
            w(0, 1) = 0.087807628716604; w(0, 2) = 0.087807628716604; w(0, 3) = 0.087807628716604; w(0, 4) = 0.026673617804419;
            w(0, 5) = 0.026673617804419; w(0, 6) = 0.026673617804419; w(0, 7) = 0.038556880445128; w(0, 8) = 0.038556880445128;
            w(0, 9) = 0.038556880445128; w(0, 10) = 0.038556880445128; w(0, 11) = 0.038556880445128; w(0, 12) = 0.038556880445128;
            break;
        }
        break;
    case 1:
        switch (q)
        {
        case 1: // Order 3 Dunavant Points
            w(0, 0) = -0.281250000000000;
            w(0, 1) = 0.260416666666667; w(0, 2) = 0.260416666666667; w(0, 3) = 0.260416666666667;
            break;

        case 2: // Order 5 Dunavant Points
            w(0, 0) = 0.112500000000000; w(0, 1) = 0.066197076394253; w(0, 2) = 0.066197076394253;
            w(0, 3) = 0.066197076394253; w(0, 4) = 0.062969590272414; w(0, 5) = 0.062969590272414; w(0, 6) = 0.062969590272414;
            break;

        case 3: // Order 7 Dunavant Points
            w(0, 0) = -0.074785022233841;
            w(0, 1) = 0.087807628716604; w(0, 2) = 0.087807628716604; w(0, 3) = 0.087807628716604; w(0, 4) = 0.026673617804419;
            w(0, 5) = 0.026673617804419; w(0, 6) = 0.026673617804419; w(0, 7) = 0.038556880445128; w(0, 8) = 0.038556880445128;
            w(0, 9) = 0.038556880445128; w(0, 10) = 0.038556880445128; w(0, 11) = 0.038556880445128; w(0, 12) = 0.038556880445128;
            break;
        }
        break;
    case 2:
        switch (q)
        {
        case 1: // Order 5 Dunavant Points
            w(0, 0) = 0.112500000000000; w(0, 1) = 0.066197076394253; w(0, 2) = 0.066197076394253;
            w(0, 3) = 0.066197076394253; w(0, 4) = 0.062969590272414; w(0, 5) = 0.062969590272414; w(0, 6) = 0.062969590272414;
            break;

        case 2: // Order 7 Dunavant Points
            w(0, 0) = -0.074785022233841;
            w(0, 1) = 0.087807628716604; w(0, 2) = 0.087807628716604; w(0, 3) = 0.087807628716604; w(0, 4) = 0.026673617804419;
            w(0, 5) = 0.026673617804419; w(0, 6) = 0.026673617804419; w(0, 7) = 0.038556880445128; w(0, 8) = 0.038556880445128;
            w(0, 9) = 0.038556880445128; w(0, 10) = 0.038556880445128; w(0, 11) = 0.038556880445128; w(0, 12) = 0.038556880445128;
            break;

        case 3: // Order 9 Dunavant Points
            w(0, 0) = 0.048567898141400; w(0, 1) = 0.015667350113570; w(0, 2) = 0.015667350113570; w(0, 3) = 0.015667350113570;
            w(0, 4) = 0.038913770502387; w(0, 5) = 0.038913770502387; w(0, 6) = 0.038913770502387;
            w(0, 7) = 0.039823869463605; w(0, 8) = 0.039823869463605; w(0, 9) = 0.039823869463605;
            w(0, 10) = 0.012788837829349; w(0, 11) = 0.012788837829349; w(0, 12) = 0.012788837829349;
            w(0, 13) = 0.021641769688645; w(0, 14) = 0.021641769688645; w(0, 15) = 0.021641769688645;
            w(0, 16) = 0.021641769688645; w(0, 17) = 0.021641769688645; w(0, 18) = 0.021641769688645;
            break;
        }
        break;
    case 3:
        switch (q)
        {
        case 1: // Order 7 Dunavant Points
            w(0, 0) = -0.074785022233841;
            w(0, 1) = 0.087807628716604; w(0, 2) = 0.087807628716604; w(0, 3) = 0.087807628716604; w(0, 4) = 0.026673617804419;
            w(0, 5) = 0.026673617804419; w(0, 6) = 0.026673617804419; w(0, 7) = 0.038556880445128; w(0, 8) = 0.038556880445128;
            w(0, 9) = 0.038556880445128; w(0, 10) = 0.038556880445128; w(0, 11) = 0.038556880445128; w(0, 12) = 0.038556880445128;
            break;

        case 2: // Order 9 Dunavant Points
            w(0, 0) = 0.048567898141400; w(0, 1) = 0.015667350113570; w(0, 2) = 0.015667350113570; w(0, 3) = 0.015667350113570;
            w(0, 4) = 0.038913770502387; w(0, 5) = 0.038913770502387; w(0, 6) = 0.038913770502387;
            w(0, 7) = 0.039823869463605; w(0, 8) = 0.039823869463605; w(0, 9) = 0.039823869463605;
            w(0, 10) = 0.012788837829349; w(0, 11) = 0.012788837829349; w(0, 12) = 0.012788837829349;
            w(0, 13) = 0.021641769688645; w(0, 14) = 0.021641769688645; w(0, 15) = 0.021641769688645;
            w(0, 16) = 0.021641769688645; w(0, 17) = 0.021641769688645; w(0, 18) = 0.021641769688645;
            break;

        case 3: // Order 12 Dunavant Points
            w(0, 0) = 0.012865533220227; w(0, 1) = 0.012865533220227; w(0, 2) = 0.012865533220227; w(0, 3) = 0.021846272269019; w(0, 4) = 0.021846272269019;
            w(0, 5) = 0.021846272269019; w(0, 6) = 0.031429112108943; w(0, 7) = 0.031429112108943; w(0, 8) = 0.031429112108943;
            w(0, 9) = 0.017398056465355; w(0, 10) = 0.017398056465355; w(0, 11) = 0.017398056465355; w(0, 12) = 0.003083130525780;
            w(0, 13) = 0.003083130525780; w(0, 14) = 0.003083130525780; w(0, 15) = 0.020185778883191; w(0, 16) = 0.020185778883191;
            w(0, 17) = 0.020185778883191; w(0, 18) = 0.020185778883191; w(0, 19) = 0.020185778883191; w(0, 20) = 0.020185778883191;
            w(0, 21) = 0.011178386601152; w(0, 22) = 0.011178386601152; w(0, 23) = 0.011178386601152; w(0, 24) = 0.011178386601152;
            w(0, 25) = 0.011178386601152; w(0, 26) = 0.011178386601152; w(0, 27) = 0.008658115554329; w(0, 28) = 0.008658115554329;
            w(0, 29) = 0.008658115554329; w(0, 30) = 0.008658115554329; w(0, 31) = 0.008658115554329; w(0, 32) = 0.008658115554329;
            break;
        }
        break;
    }
    return w;
}

MatrixXd MassMatrix(int p, int q) {
    //Use for all linear elements, invert and multiply by 1/det(J)
    int rank = (p+1)*(p+2)/2;
    MatrixXd bq = BasisQuad(p,q);
    MatrixXd w = Quad(p,q);
    MatrixXd f(1,w.cols());
    MatrixXd M(rank,rank);
    for (int i=0; i<rank; i++) {
        for (int j=0; j<rank; j++) {
            f = bq(i,all).cwiseProduct(bq(j,all));
            M(i,j) = (w.cwiseProduct(f)).sum();
        }
    }
    return M;
}

MatrixXd MassMatrixCurv(MatrixXd J, int p, int q) {
    //Use for individual curved elements, already multiplied by det(J), just needs to be inverted
    int rank = (p+1)*(p+2)/2;
    MatrixXd bq = BasisQuad(p,q);
    MatrixXd w = Quad(p,q);
    MatrixXd f(1,w.cols());
    MatrixXd M(rank,rank);
    MatrixXd det = J(all,0).cwiseProduct(J(all,3))-J(all,1).cwiseProduct(J(all,2));
    MatrixXd dJ = det.transpose();
    for (int i=0; i<rank; i++) {
        for (int j=0; j<rank; j++) {
            f = bq(i,all).cwiseProduct(bq(j,all));
            M(i,j) = (w.cwiseProduct(f.cwiseProduct(dJ))).sum();
        }
    }
    return M;
}

MatrixXd Jac(MatrixXd N, MatrixXi E) {
    //Convention: Jacobians stored as a Nx4 matrix with each row containing (in order):
    //dx/dxi, dx/deta, dy/dxi, dy/deta
    int n = E.rows();
    MatrixXd J(n,4); 
    MatrixXi H = MatrixXi::Constant(n,1,1); //vectorized index correction, the things I do for optimization...
    MatrixXd x1 = N(E(all,0)-H,0);
    MatrixXd x2 = N(E(all,1)-H,0);
    MatrixXd x3 = N(E(all,2)-H,0);
    MatrixXd y1 = N(E(all,0)-H,1);
    MatrixXd y2 = N(E(all,1)-H,1);
    MatrixXd y3 = N(E(all,2)-H,1);
    J(all,0) = x2-x1;
    J(all,1) = x3-x1;
    J(all,2) = y2-y1;
    J(all,3) = y3-y1;
    return J;
}

MatrixXd InvJac(MatrixXd N, MatrixXi E, MatrixXd J) {
    int n = E.rows();
    MatrixXi H = MatrixXi::Constant(n,1,1);
    MatrixXd dJ(n,1);
    dJ = J(all,0).cwiseProduct(J(all,3))-J(all,1).cwiseProduct(J(all,2)); //det(J), if needed elsewhere this gets it
    MatrixXd iJ(n,4); //follows same convention as Jacobian matrix (but inverse)
    MatrixXd x1 = N(E(all,0)-H,0);
    MatrixXd x2 = N(E(all,1)-H,0);
    MatrixXd x3 = N(E(all,2)-H,0);
    MatrixXd y1 = N(E(all,0)-H,1);
    MatrixXd y2 = N(E(all,1)-H,1);
    MatrixXd y3 = N(E(all,2)-H,1);
    iJ(all,0) = y3-y1;
    iJ(all,1) = x1-x3;
    iJ(all,2) = y1-y2;
    iJ(all,3) = x2-x1;
    return iJ;
}

MatrixXd CurvJacInt(MatrixXd N, int p, int q) {
    //N is a (nq x 2) matrix containing the coordinates of just the nq nodes on a given curved element (in rank order!!), not the full N matrix
    //p is the solution order, q is the geometry order
    int nq = (q+1)*(q+2)/2;
    MatrixXd qg = BasisGradQuadJac(p,q);
    int np = qg.cols()/2;
    MatrixXd Jac(np,4);
    for (int i=0; i<np; i++) {
        Jac(i,0) = (N(all,0).cwiseProduct(qg(all,2*i))).sum();
        Jac(i,1) = (N(all,0).cwiseProduct(qg(all,2*i+1))).sum();
        Jac(i,2) = (N(all,1).cwiseProduct(qg(all,2*i))).sum();
        Jac(i,3) = (N(all,1).cwiseProduct(qg(all,2*i+1))).sum();
    }
    return Jac;
    //returns an (np x 4) matrix of the Jacobian elements at each quadrature point
    //works on linear elements but is slower than prior function because each point is done individually
}

MatrixXd CurvJac(MatrixXd xy, MatrixXd N, int q) {
    //Use for calculating Jacobian at arbitrary point, should only be called by other functions
    MatrixXd g = BasisGrad(xy,q);
    MatrixXd J(1,4);
    J(0,0) = (N(all,0).cwiseProduct(g(all,0))).sum();
    J(0,1) = (N(all,0).cwiseProduct(g(all,1))).sum();
    J(0,2) = (N(all,1).cwiseProduct(g(all,0))).sum();
    J(0,3) = (N(all,1).cwiseProduct(g(all,1))).sum();
    return J;
}

MatrixXd InvCurvJac(MatrixXd J) {
    int np = J.rows();
    MatrixXd iJ(J.rows(),J.cols());
    MatrixXd det(J.rows(),1);
    det = J(all,0).cwiseProduct(J(all,3)) - J(all,1).cwiseProduct(J(all,2));
    iJ(all,0) = J(all,3).cwiseQuotient(det);
    iJ(all,1) = -J(all,1).cwiseQuotient(det);
    iJ(all,2) = -J(all,2).cwiseQuotient(det);
    iJ(all,3) = J(all,0).cwiseQuotient(det);
    return iJ;
}

MatrixXd Normal(double s, MatrixXd N, int q, int edge) {
    //s is the 1D quad point location on the edge where the normal is needed (in reference space)
    //N is the node coordinates defining the element geometry (larger for larger q)
    //q is the geometry order of the element
    //edge is the edge number (1, 2, or 3) the normal is needed on
    //edge numbers are equivalent to connect matrix number, i.e. edge 1/2/3 is opposite node 1/2/3 in elem matrix
    MatrixXd n(1,2);
    int rank = (q+1)*(q+2)/2;
    MatrixXd xy(1,2);
    MatrixXd t(1,2);
    MatrixXd J(1,4);
    switch(edge) {
    case 1: 
        xy(0,0) = 1-s;
        xy(0,1) = s;
        J = CurvJac(xy,N,q);
        t(0,0) = -J(0,0)+J(0,1); t(0,1) = -J(0,2)+J(0,3);
        //t = t/sqrt(t(0,0)*t(0,0)+t(0,1)*t(0,1));
        n(0,0) = t(0,1); n(0,1) = -t(0,0);
        break;
    case 2:
        xy(0,0) = 0;
        xy(0,1) = 1-s;
        J = CurvJac(xy,N,q);
        t(0,0) = -J(0,1); t(0,1) = -J(0,3);
        //t = t/sqrt(t(0,0)*t(0,0)+t(0,1)*t(0,1));
        n(0,0) = t(0,1); n(0,1) = -t(0,0);
        break;
    case 3:
        xy(0,0) = s;
        xy(0,1) = 0;
        J = CurvJac(xy,N,q);
        t(0,0) = J(0,0); t(0,1) = J(0,2);
        //t = t/sqrt(t(0,0)*t(0,0)+t(0,1)*t(0,1));
        n(0,0) = t(0,1); n(0,1) = -t(0,0);
        break;
    }
    return n;
    //n is the non-normalized normal vector. To use the normal, take n/norm(n). To get ds/dsigma, take norm(n).
} 

MatrixXd Quad1(int p, int q) {
    int o = 2*p+1+q-1;
    int np = ceil((o-1)/2)+1; 
    MatrixXd sw(np,2); //includes coords and weights of 1d quad points
    switch(np) {
    case 1:
        sw(0,0) = 0.5;
        sw(0,1) = 1;
        break;
    case 2: 
        sw.col(0) << 0.211324865405187, 0.788675134594813;
        sw.col(1) << 0.500000000000000, 0.500000000000000;
        break;
    case 3: 
        sw(all,0) << 0.112701665379258, 0.500000000000000, 0.887298334620742;
        sw(all,1) << 0.277777777777778, 0.444444444444444, 0.277777777777778;
        break;
    case 4: 
        sw(all,0) << 0.069431844202974, 0.330009478207572, 0.669990521792428, 0.930568155797026;
        sw(all,1) << 0.173927422568727, 0.326072577431273, 0.326072577431273, 0.173927422568727;
        break;
    case 5: 
        sw(all,0) << 0.046910077030668, 0.230765344947158, 0.500000000000000, 0.769234655052841,
            0.953089922969332;
        sw(all,1) << 0.118463442528095, 0.239314335249683, 0.284444444444444, 0.239314335249683,
            0.118463442528095;
        break;
    case 6: 
        sw(all,0) << 0.033765242898424, 0.169395306766868, 0.380690406958402, 0.619309593041598,
            0.830604693233132, 0.966234757101576;
        sw(all,1) << 0.085662246189585, 0.180380786524069, 0.233956967286345, 0.233956967286345,
            0.180380786524069, 0.085662246189585;
        break;
    }
    return sw;
}

struct Pre {
    MatrixXd iMM;
    MatrixXd BQ2;
    MatrixXd BQ2g;
    MatrixXd w2;
    MatrixXd iJ;
    MatrixXd dJ;
    MatrixXd BQ1;
    MatrixXd w1;
    MatrixXd nvec;
    MatrixXd A;
    MatrixXd s1;
};

struct Pre PreComp(MatrixXd N, MatrixXi E, int p, int q) {
    //Driver function that precomputes everything for entire mesh, run this after loading meshes
    int ne = E.rows();
    int rank = (p+1)*(p+2)/2;
    int qrank = (q+1)*(q+2)/2;

    //Basis Functions, Gradients and Weights at Quad Points (reference space)
    MatrixXd BQ2 = BasisQuad(p,q); 
    MatrixXd BQ2g = BasisGradQuad(p,q);
    MatrixXd w2 = Quad(p,q);
    int np = w2.cols();
    

    //Interior Element Calcs included Mass Matrices
    MatrixXd J(np,4);
    MatrixXd iJ(ne*np,4);
    MatrixXd dJ(ne*np,1);
    MatrixXd iMM(rank*ne,rank);
    MatrixXi H = MatrixXi::Constant(E.rows(),E.cols(),1);
    MatrixXi Ec(E.rows(),E.cols());
    Ec = E - H;
    for (int i=0; i<ne; i++) {
        J = CurvJacInt(N(Ec(i,all),all),p,q);
        dJ(seq(i*np,(i+1)*np-1,1),0) = J(all,0).cwiseProduct(J(all,3)) - J(all,1).cwiseProduct(J(all,2));
        iJ(seq(i*np,(i+1)*np-1,1),all) = InvCurvJac(J);
        MatrixXd MM = MassMatrixCurv(J,p,q);
        MatrixXd iM = MM.inverse();
        iMM(seq(i*rank,(i+1)*rank-1,1),all) = iM;
        if (i%1000 == 0) {
            cout << i << "\n";
        }
    }
    cout << "Mass Matrices Complete \n";

    //Edge Calcs
    MatrixXd sw = Quad1(p,q);
    MatrixXd s1 = sw(all,0);
    MatrixXd w1 = sw(all,1);
    MatrixXd nvec(3*ne*sw.rows(),2);
    for (int i=0; i<ne; i++) {
        for (int j=1; j<4; j++) {
            for (int k=0; k<sw.rows(); k++) {
                int ijk = 3*sw.rows()*i + k + sw.rows()*(j-1);
                nvec(ijk,all) = Normal(sw(k,0),N(Ec(i,all),all),q,j);
            }
        }
        if (i%1000 == 0) {
            cout << i << "\n";
        }
    }
    cout << "Normals Complete \n";
    MatrixXd xy(1,2);
    MatrixXd BQ1(rank,3*sw.rows());
    for (int k=0; k<sw.rows(); k++) {
        for (int j=1; j<4; j++) {
            switch(j) {
            case 1: 
                xy(0,0) = 1-sw(k,0);
                xy(0,1) = sw(k,0);
                BQ1(all,k+sw.rows()*(j-1)) = Basis(xy,p);
                break;
            case 2:
                xy(0,0) = 0;
                xy(0,1) = 1-sw(k,0);
                BQ1(all,k+sw.rows()*(j-1)) = Basis(xy,p);
                break;
            case 3:
                xy(0,0) = sw(k,0);
                xy(0,1) = 0;
                BQ1(all,k+sw.rows()*(j-1)) = Basis(xy,p);
                break;
            }
        }
    }
    MatrixXd BQ1t = BQ1.transpose();
    cout << "Edges Complete \n";

    MatrixXd A(ne,1);
    for (int i=0; i<ne; i++) {
        MatrixXd det = dJ(seq(i*np,(i+1)*np-1,1),0);
        MatrixXd area = w2*det;
        A(i,0) = area(0,0);
    }
  

    struct Pre S;
    S.iMM = iMM; //(ne*rank x rank) stack of all element inverted mass matrices
    S.BQ2 = BQ2; //(rank x np) matrix of basis functions evaluated at interior quad points
    S.BQ2g = BQ2g; //(rank x 2*np) matrix of basis function gradients evaluated at interior quad points
    S.w2 = w2; //(1 x np) matrix of weight at interior quad points
    S.iJ = iJ; //(np*ne x 4) matrix of unrolled inverse jacobians at interior quad points on all elements
    S.dJ = dJ; //(np*ne x 1) matrix of det(J) at interior quad points on all elements
    S.BQ1 = BQ1t; //(3*np1 x rank) matrix of basis functions at edge quad points on all 3 edges of ref. element
    S.w1 = w1; //(np1 x 1) matrix of 1d quad weights
    S.nvec = nvec; //(3*np1*ne x 2) matrix of normal vectors at quad points on each edge of each element
    S.A = A; //(ne x 1) matrix of element areas
    S.s1 = s1;
    return S;
}

MatrixXd Uquad(MatrixXd BQ2, MatrixXd Ubasis)
{
    //int rank = (p + 1) * (p + 2) / 2;
    //MatrixXi np(4, 1); np(0, 0) = 4; np(1, 0) = 4; np(2, 0) = 7; np(3, 0) = 13; 
    MatrixXd BQ = BQ2.transpose();
    MatrixXd A = BQ * Ubasis;

    return A;
}

MatrixXd EulerFluxX(MatrixXd BQ2, MatrixXd Ubasis, int p, int q, double gamma)
{
    int nsv = 4;
    int rank = (p + 1) * (p + 2) / 2;
    MatrixXi np(4, 3); np(0, 0) = 4; np(1, 0) = 4; np(2, 0) = 7; np(3, 0) = 13;
    np(0, 1) = 7; np(1, 1) = 7; np(2, 1) = 13; np(3, 1) = 19;
    np(0, 2) = 13; np(1, 2) = 13; np(2, 2) = 19; np(3, 2) = 33;
    MatrixXd Fx(np(p, q - 1), nsv);

    MatrixXd uquad = Uquad(BQ2, Ubasis);

    for (int i = 0; i < np(p, q - 1); i++)
    {
        double prs = (gamma - 1) * (uquad(i, 3) - ((pow(uquad(i, 1), 2) + pow(uquad(i, 2), 2)) / (2 * uquad(i, 0))));
        double H = (prs + uquad(i, 3)) / uquad(i, 0);
        Fx(i, 0) = uquad(i, 1);
        Fx(i, 1) = (pow(uquad(i, 1), 2) / uquad(i, 0)) + prs;
        Fx(i, 2) = uquad(i, 1) * uquad(i, 2) / uquad(i, 0);
        Fx(i, 3) = uquad(i, 1) * H;
    }

    return Fx;
}

MatrixXd EulerFluxY(MatrixXd BQ2, MatrixXd Ubasis, int p, int q, double gamma)
{
    int nsv = 4;
    MatrixXi np(4, 3); np(0, 0) = 4; np(1, 0) = 4; np(2, 0) = 7; np(3, 0) = 13;
    np(0, 1) = 7; np(1, 1) = 7; np(2, 1) = 13; np(3, 1) = 19;
    np(0, 2) = 13; np(1, 2) = 13; np(2, 2) = 19; np(3, 2) = 33;
    int rank = (p + 1) * (p + 2) / 2;
    MatrixXd Fx(np(p, q - 1), nsv);

    MatrixXd uquad = Uquad(BQ2, Ubasis);

    for (int i = 0; i < np(p, q - 1); i++)
    {
        double prs = (gamma - 1) * (uquad(i, 3) - ((pow(uquad(i, 1), 2) + pow(uquad(i, 2), 2)) / (2 * uquad(i, 0))));
        double H = (prs + uquad(i, 3)) / uquad(i, 0);
        Fx(i, 0) = uquad(i, 2);
        Fx(i, 1) = uquad(i, 1) * uquad(i, 2) / uquad(i, 0);
        Fx(i, 2) = (pow(uquad(i, 2), 2) / uquad(i, 0)) + prs;
        Fx(i, 3) = uquad(i, 2) * H;
    }
    return Fx;
}

MatrixXd Res_Elem_Int_Indv(MatrixXd BQ2, MatrixXd BQ2g, MatrixXd w2, MatrixXd iJe, MatrixXd dJe, MatrixXd U_basis, MatrixXd R_ki, double gamma, int p, int q)
{
    // This function calculates the Residual in Element Interior for INDIVIDUAL ELEMENT!!
    // iJe is the inverse of the Jacobian for ALL quad points in AN element, so its dimension is (np(p,q-1)x4)
    // dJe is the determinant of the Jacobian for ALL quad points in AN element, so its dimension is (np(p,q-1)x1)
    // U_basis is the state at ALL basis points for AN element, so its dimension is (rank x nsv)
    // R_ki is the previous residual at ALL basis points for AN element, so its dimension is (rank x nsv)
    // nsv = No. of state variables (= 4 for Euler)
    
    
    int nsv = 4;
    int np = w2.cols();   //Gives number of quadrature points
    int rank = (p + 1) * (p + 2) / 2;

    /*  Backup
    MatrixXi np(4, 3); np(0, 0) = 4; np(1, 0) = 4; np(2, 0) = 7; np(3, 0) = 13;
                       np(0, 1) = 7; np(1, 1) = 7; np(2, 1) = 13; np(3, 1) = 19;
                       np(0, 2) = 13; np(1, 2) = 13; np(2, 2) = 19; np(3, 2) = 33;
    */
    MatrixXd Res(rank, nsv);

    MatrixXd uquad = Uquad(BQ2, U_basis);                               //size (np,nsv);  State at all quad points
    MatrixXd Fx_quad = EulerFluxX(BQ2, U_basis, p, q, gamma);           //size (np, nsv); X-Flux at all quad points
    MatrixXd Fy_quad = EulerFluxY(BQ2, U_basis, p, q, gamma);           //size (np, nsv); Y Flux at all quad points
    MatrixXd GradBX_Quad(rank, np);                                     //size (rank, np); X- Basis fn gradients at all quad points
    MatrixXd GradBY_Quad(rank, np);                                     //size (rank, np); Y- Basis fn gradients at all quad points

    for (int i = 0; i < rank; i++)
    {
        for (int j = 0; j < np; j++)
        {
            GradBX_Quad(i, j) = BQ2g(i, (2 * j));
            GradBY_Quad(i, j) = BQ2g(i, (2 * j)+1);
        }
    } 
    
    MatrixXd iJac(2, 2);            // Inverse Jacobian matrix at a quad point
    MatrixXd grad_req(1, 2);        // X- and Y- Basis fn gradient req. at a quad point
    MatrixXd F(2, 1);               // X- and Y- Euler Flux req. at a quad point

    for (int j = 0; j < rank; j++)
    {
        for (int k = 0; k < nsv; k++)
        {
            //Res(j, k) = 0;
            double sum = 0;
            for (int i = 0; i < np; i++)
            {
                grad_req(0, 0) = GradBX_Quad(j, i);
                grad_req(0, 1) = GradBY_Quad(j, i);

                iJac(0, 0) = iJe(i, 0);
                iJac(0, 1) = iJe(i, 1);
                iJac(1, 0) = iJe(i, 2);
                iJac(1, 1) = iJe(i, 3);

                F(0, 0) = Fx_quad(i, k) * w2(0, i) * dJe(i,0);
                F(1, 0) = Fy_quad(i, k) * w2(0, i) * dJe(i, 0);

                MatrixXd A1 = grad_req * iJac;
                MatrixXd B = A1 * F;
                //Res(j, k) += B(0,0);
                sum += B(0, 0);
            }
            Res(j, k) = R_ki(j, k) - sum;
        }

    }
    return Res;
}

MatrixXd Res_Elem_Int_Total(MatrixXd BQ2, MatrixXd BQ2g, MatrixXd w2, MatrixXd iJ, MatrixXd dJ, MatrixXd U_basis_all, MatrixXd R_k, double gamma, int p, int q)
{
    // INPUTS: 
    // U_basis_all : Present State at all basis points for ENTIRE MESH
    // R_k: Previous Residual at all basis points for ENTIRE MESH
    // iJ : Inverse Jacobian Matrix elements for ENTIRE MESH, to be input from PreComp
    // dJ = Jacobian determinant for ENTIRE MESH, to be input from PreComp
    // BQ2, BQ2g, w2 to be taken from PreComp


    // This function loops over the elements, gets the inverse Jacobian, JAcobian determinant at all quad points 
    // and present state and previous residual at all basis points for each element, gets the individual element residual
    // by calling the function above, and finally adding it to a matrix of revised residuals

    int np = w2.cols();
    int npne = dJ.rows();
    int ne = npne / np;
    int rank = (p + 1) * (p + 2) / 2;
    int nsv = 4;
    MatrixXd Res_entire(ne * rank, 4);

    // Quantities for individual element
    MatrixXd iJe(np, 4);
    MatrixXd dJe(np, 1);
    MatrixXd R_ki(rank, nsv); 
    MatrixXd U_basis(rank, nsv);

    for (int i = 0; i < ne; i++)
    {
        
        for (int j = 0; j < np; j++)
        {
            iJe(j, all) = iJ((np * i) + j, all);
            dJe(j, all) = dJ((np * i) + j, all);
        }

        for (int k = 0; k < rank; k++)
        {
            R_ki(k, all) = R_k((rank*i)+k,all);
            U_basis(k, all) = U_basis_all((rank * i) + k, all);
        }

        MatrixXd Res_elem = Res_Elem_Int_Indv(BQ2, BQ2g, w2, iJe, dJe, U_basis, R_ki, gamma, p, q);
        
        for (int k = 0; k < rank; k++)
        {
             Res_entire((rank * i) + k, all) = Res_elem(k, all);
        }
    }

    // You'd want to subtract/add edge residues from Res_entire, so pass that as input; can be clarified from notes
    return Res_entire;
}

struct Res {
    MatrixXd Resl;
    MatrixXd Resr;
    MatrixXd smag;
};

MatrixXi rotCCW(MatrixXi i1, int p) {
    int rank = (p+1)*(p+2)/2;
    MatrixXi i2(1,rank);
    MatrixXi ii(1,rank);
    if (p == 2) {
        i2 << 5, 3, 0, 4, 1, 2;
    } else if (p == 3) {
        i2 << 9, 7, 4, 0, 8, 5, 1, 6, 2, 3;
    }
    for (int i=0; i<rank; i++) {
        ii(0,i) = i1(0,i2(0,i));
    }
    return ii;
}

MatrixXi flip(MatrixXi i1, int p) {
    int rank = (p+1)*(p+2)/2;
    MatrixXi i2(1,rank);
    MatrixXi ii(1,rank);
    if (p == 2) {
        i2 << 0, 3, 5, 1, 4, 2;
    } else if (p == 3) {
        i2 << 0, 4, 7, 9, 1, 5, 8, 2, 6, 3;
    }
    for (int i=0; i<rank; i++) {
        ii(0,i) = i1(0,i2(0,i));
    }
    return ii;
}

MatrixXi erot(int eL, int eR, int p) {
    int rank = (p+1)*(p+2)/2;
    eL = eL-1;
    eR = eR-1;
    MatrixXi ii(1,rank);
    for (int i=0; i<rank; i++) {
        ii(0,i) = i;
    }
    //cout << ii << "\n";
    for (int i=0; i<eL; i++) {
        ii = rotCCW(rotCCW(ii,p),p);
        //cout << ii << "\n";
    }
    ii = flip(ii,p);
    //cout << ii << "\n";
    for (int i=0; i<eR; i++) {
        ii = rotCCW(ii,p);
        //cout << ii << "\n";
    }
    return ii;
}

struct Res Res_Elem_Edge_Indv(int ie, int e, int er, MatrixXd BQ1,MatrixXd s, MatrixXd w1, MatrixXd nvec, MatrixXd U_basisL, MatrixXd U_basisR, MatrixXd R_ki, MatrixXd R_rki, double gamma, int p, int q)
{
    // This function calculates the Residual in Element Edges for INDIVIDUAL ELEMENT!!
    
    // dJe is the determinant of the Jacobian for ALL quad points in AN element, so its dimension is (npx1)
    // U_basisL is the state at ALL basis points for the left element, so its dimension is (rank x nsv)
    // R_ki is the previous residual at ALL basis points for the left element, so its dimension is (rank x nsv)
    // U_basisR is the state at ALL basis points for the right element, so its dimension is (rank x nsv)
    // R_rki is the previous residual at ALL basis points for the right element, so its dimension is (rank x nsv)
    // nsv = No. of state variables (= 4 for Euler)
    // s = quadrature points in 1D
    // w1 = quadrature weights in 1D
 

    int nsv = 4;
    int np = w1.rows();   //Gives number of quadrature points
    int rank = (p + 1) * (p + 2) / 2;
    MatrixXi ii = erot(e,er,p);
    //cout << "mapping \n";
    //cout << ii << "\n";
    MatrixXd ResL(rank, nsv);
    MatrixXd ResR(rank, nsv);
    MatrixXd uquadl = BQ1*U_basisL;                               //size (np,nsv);  State at all quad points BQ1 -> Pre compute tranpose (3(sw.size(), rank))
    //cout << BQ1(e,all) << "\n";
    MatrixXd uquadr = BQ1*U_basisR;                               //size (np,nsv);  State at all quad points BQ1 -> Pre compute tranpose (3(sw.size(), rank))
    MatrixXd uquadlreq(np,nsv);
    MatrixXd uquadrreq(np,nsv);
    // uquadl in 3*np -> Quad point over the entire ref triangle (CCW)
    for(int h=0;h<np;h++){ // choosing the edge that concerns us
        uquadlreq(h,all) = uquadl(np*(e-1) + h,all);
        uquadrreq(h,all) = uquadr(np*(er-1) + h,all);
    }
    /// Reversing the order of states on right element before Flux calculation
    MatrixXd temp = uquadrreq;
    for (int h=0;h<np;h++ ){  // Make the order of the right edgeR CW 
        uquadrreq(h,all) = temp(np-1-h,all);
    }

    MatrixXd Fx_quad(np,nsv);      //size (np, nsv); Y Flux at all quad points
    MatrixXd xy(np,2);                      // for storing the quadrature co-ordinates 
    MatrixXd smag_int(np,1);

    for (int ii=0; ii<np; ii++){

        MatrixXd nor = nvec(3*(ie)*np + (e-1)*np+ii,all);

        double magnor = sqrt(pow(nor(0,0),2) + pow(nor(0,1),2));
        // fnor normalized normals for flux calculations
        MatrixXd fnor(1,2) ;
        fnor(0,0)= nor(0,0)/magnor;
        fnor(0,1)= nor(0,1)/magnor;

        struct Flux ResidualCalcOutput;
        ResidualCalcOutput = RoeFlux(uquadlreq(ii,all), uquadrreq(ii,all), gamma, fnor);

        Fx_quad(ii,all) =  ResidualCalcOutput.F;          //size (np, nsv); X-Flux at all quad points
        smag_int(ii,0) = ResidualCalcOutput.smag;
        // MatrixXd Fy_quad(ii,all) = Roeflux(U_basisL, U_basisR, nor, gamma);          //size (np, nsv); Y Flux at all quad points

    }
    switch(e)   {
        
        case 1:
        for (int k = 0; k < s.rows(); k++) {
            xy(k, 0) = 1 - s(k,0);
            xy(k, 1) = s(k,0);
        } 
            
            break;
        case 2:
        for (int k = 0; k < s.rows(); k++) {
            xy(k, 0) = 0;
            xy(k, 1) = 1 - s(k,0);
        }  
            break;
        case 3:
        for (int k = 0; k < s.rows(); k++) {
            xy(k, 0) = s(k,0);
            xy(k, 1) = 0;
        }   
            break;   
    }
    
        //(npx1)
    for (int j = 0; j < rank; j++)
    {
        for (int k = 0; k < nsv; k++)
        {
            //Res(j, k) = 0;
            double sum = 0;
            for (int i = 0; i < np; i++)
            {
                
                MatrixXd nor = nvec(3*(ie)*np+(e-1)*np+i,all);	
                double magnor = sqrt(pow(nor(0,0),2) + pow(nor(0,1),2));
		
                // ds/d(sigma) = magnor
                // F = flux * quad_weight* Edge Jacobian determinant * ds/d(sigma)
                MatrixXd F(1,1);
                F(0,0) = Fx_quad(i, k) * w1(i, 0)*magnor;
                MatrixXd A1(1,1);
                A1(0,0) = BQ1((e-1)*np+i,j);
                MatrixXd B(1,1);
	            B(0,0) = A1(0,0) * F(0,0);
                //Res(j, k) += B(0,0);
                sum += B(0, 0);

            }
            //cout << "rank: " << j << " sum: " << sum << "\n";
            ResL(j,k) = R_ki(j,k) + sum;
            ResR(ii(0,j),k) = R_rki(ii(0,j),k) - sum;
            // for elemR
            /*if (er == e) {
                if (p == 0) {
                    ResR(j,k) = R_rki(j,k) - sum;
                } else if (p == 1) {
                    MatrixXi rot(1,3);
                    //rot << 0, 1, 2;
                    rot(0,e-1) = e-1;
                    rot(0,e%3) = (e+1)%3;
                    rot(0,(e+1)%3) = e%3;
                    ResR(rot(0,j),k) = R_rki(rot(0,j),k) - sum;
                } else if (p == 2) {
                    MatrixXi rot(1,6);
                    //rot << 5, 3, 0, 4, 1, 2;
                    rot << 0, 3, 5, 1, 4, 2;
                    ResR(rot(0,j),k) = R_rki(rot(0,j),k) - sum;
                } else if (p == 3) {
                    MatrixXi rot(1,10);
                    rot << 0, 4, 7, 9, 1, 5, 8, 2, 6, 3;
                    ResR(rot(0,j),k) = R_rki(rot(0,j),k) - sum;
                }
            } else if ((er-1)%3 == (e)%3) {
                if (p == 0) {
                    ResR(j,k) = R_rki(j,k) - sum;
                } else if (p == 1) {
                    MatrixXi rot(1,3);
                    rot << 1, 0, 2;
                    rot(0,(e+1)%3) = (e+1)%3;
                    rot(0,e%3) = (e-1)%3;
                    rot(0,(e-1)%3) = e%3;
                    ResR(rot(0,j),k) = R_rki(rot(0,j),k) - sum;
                } else if (p == 2) {
                    MatrixXi rot(1,6);
                    rot << 2, 1, 0, 4, 3, 5;
                    ResR(rot(0,j),k) = R_rki(rot(0,j),k) - sum;
                } else if (p == 3) {
                    MatrixXi rot(1,10);
                    rot << 3, 2, 1, 0, 6, 5, 4, 8, 7, 9;
                    ResR(rot(0,j),k) = R_rki(rot(0,j),k) - sum;
                }
            } else {
                if (p == 0) {
                    ResR(j,k) = R_rki(j,k) - sum;
                } else if (p == 1) {
                    MatrixXi rot(1,3);
                    rot(0,(e)%3) = (e)%3;
                    rot(0,(e+1)%3) = (e-1)%3;
                    rot(0,(e-1)%3) = (e+1)%3;
                    ResR(rot(0,j),k) = R_rki(rot(0,j),k) - sum;
                } else if (p == 2) {
                    MatrixXi rot(1,6);
                    rot << 5, 4, 2, 3, 1, 0;
                    ResR(rot(0,j),k) = R_rki(rot(0,j),k) - sum;
                } else if (p == 3) {
                    MatrixXi rot(1,10);
                    rot << 9, 8, 6, 3, 7, 5, 2, 4, 1, 0;
                    ResR(rot(0,j),k) = R_rki(rot(0,j),k) - sum;
                }
            }*/
        }

    }
    // return Res;
    
    struct Res R;
    R.Resl = ResL; 
    R.Resr = ResR;
    R.smag = smag_int.colwise().maxCoeff(); 
    return R;
}

struct Res Res_Elem_Edge_Indv_BC(int BC, int ie, int e, MatrixXd BQ1, MatrixXd Uinf, MatrixXd s, MatrixXd w1, MatrixXd nvec, MatrixXd U_basisL, MatrixXd R_ki, double gamma, int p, int q)
{
    // This function calculates the Residual in Element Edges for INDIVIDUAL ELEMENT!!
    
    // dJe is the determinant of the Jacobian for ALL quad points in AN element, so its dimension is (npx1)
    // U_basisL is the state at ALL basis points for the left element, so its dimension is (rank x nsv)
    // R_ki is the previous residual at ALL basis points for the left element, so its dimension is (rank x nsv)
    // U_basisR is the state at ALL basis points for the right element, so its dimension is (rank x nsv)
    // R_rki is the previous residual at ALL basis points for the right element, so its dimension is (rank x nsv)
    // nsv = No. of state variables (= 4 for Euler)
    // s = quadrature points in 1D
    // w1 = quadrature weights in 1D

    //
    
    int nsv = 4;
    int np = w1.rows();   //Gives number of quadrature points
    int rank = (p + 1) * (p + 2) / 2;

    MatrixXd ResL(rank, nsv);
    MatrixXd ResR(rank, nsv);

    MatrixXd uquadl = BQ1*U_basisL;                               //size (np,nsv);  State at all quad points BQ1 -> Pre compute tranpose (3(sw.size(), rank))
    MatrixXd Fx_quad(np,nsv);      //size (np, nsv); Y Flux at all quad points
    MatrixXd xy(np,2);                      // for storing the quadrature co-ordinates 
    MatrixXd smag_int(np,1);

    MatrixXd uquadlreq(np,nsv);
    MatrixXd uquadrreq(np,nsv);
    // uquadl in 3*np -> Quad point over the entire ref tr
    for(int h=0;h<np;h++){
        uquadlreq(h,all) = uquadl(np*(e-1) + h,all);
	
    }

    for (int ii=0; ii<np; ii++){
        MatrixXd nor = nvec(3*(ie)*np+(e-1)*np+ii,all);
        double magnor = sqrt(pow(nor(0,0),2) + pow(nor(0,1),2));
        // fnor normalized normals for flux calculations
        MatrixXd fnor(1,2) ;
        fnor(0,0)= nor(0,0)/magnor;
        fnor(0,1)= nor(0,1)/magnor;
 
	struct Flux ResidualCalcOutput;
	
        if (BC == -1)      //far field boundary
        {
            	ResidualCalcOutput = RoeFlux(uquadlreq(ii,all), Uinf(ii,all), gamma, fnor);

	        Fx_quad(ii, all) = ResidualCalcOutput.F;
	        smag_int(ii, 0) = ResidualCalcOutput.smag;


        } else
        {
            ResidualCalcOutput = WallFlux(uquadlreq(ii,all), gamma, fnor);
        
            Fx_quad(ii,all) =  ResidualCalcOutput.F;          //size (np, nsv); X-Flux at all quad points
            smag_int(ii,0) = ResidualCalcOutput.smag;
	}

        // MatrixXd Fy_quad(ii,all) = Roeflux(U_basisL, U_basisR, nor, gamma);          //size (np, nsv); Y Flux at all quad points

    }


    //(npx1)
    for (int j = 0; j < rank; j++)
    {
        for (int k = 0; k < nsv; k++)
        {
            //Res(j, k) = 0;
            double sum = 0;
            for (int i = 0; i < np; i++)
            {
                MatrixXd nor = nvec(3*(ie)*np+ (e-1)*np+i,all);
                double magnor = sqrt(pow(nor(0,0),2) + pow(nor(0,1),2));
                // ds/d(sigma) = magnor
                // F = flux * quad_weight* Edge Jacobian determinant * ds/d(sigma)
                MatrixXd F(1,1);
                F(0,0) = Fx_quad(i, k) * w1(i,0)*magnor;
		
                MatrixXd A1(1,1);
                A1(0,0) = BQ1(i+(e-1)*np,j);
                //cout << "edge: " << e << " basis: " << j << " A1: " << A1 << "\n";
                MatrixXd B(1,1);
		        B(0,0) = A1(0,0) * F(0,0);
                //cout << "A1 = " << A1(0,0) << "\n";

                //Res(j, k) += B(0,0);
                sum += B(0, 0);


	    }
            ResL(j, k) = R_ki(j,k) + sum;

        }
	
    }
    struct Res R;
    R.Resl = ResL; //(ne*rank x rank) stack of all element inverted mass matrices
    R.smag = smag_int.colwise().maxCoeff();

    //cout <<"from boundaries \n";
    //cout << ResL << "\n";

    return R;

}

struct Res_Fin
{
    MatrixXd R;
    MatrixXd smag;
};


struct Res_Fin Res_Elem_Edge_Total(MatrixXd Uinf, MatrixXd BQ1, MatrixXd w1, MatrixXd iJ, MatrixXd U_basis_all, MatrixXd R_k, MatrixXd s, MatrixXd nvec, double gamma, int p, int q, MatrixXi I2E, MatrixXi B2E)
{
    // INPUTS: 
    // U_basis_all : Present State at all basis points for ENTIRE MESH
    // R_k: Previous Residual at all basis points for ENTIRE MESH
    // iJ : Inverse Jacobian Matrix elements for ENTIRE MESH, to be input from PreComp
    // dJ = Jacobian determinant for ENTIRE MESH, to be input from PreComp
    // BQ2, BQ2g, w2 to be taken from PreComp


    // This function loops over the elements, gets the inverse Jacobian, JAcobian determinant at all quad points 
    // and present state and previous residual at all basis points for each element, gets the individual element residual
    // by calling the function above, and finally adding it to a matrix of revised residuals

    int np = w1.rows();
    //int npne = dJ.rows();
    int rank = (p + 1) * (p + 2) / 2;
    int nsv = 4;
    MatrixXd Res_entire(U_basis_all.rows(), 4);
    Res_entire = R_k; // taking the previous interior element residual
    MatrixXd smag((U_basis_all.rows()/rank), 3);

    // Quantities for individual element 
    MatrixXd R_ki(rank, nsv); 
    MatrixXd R_rki(rank, nsv);
    MatrixXd U_basisL(rank, nsv);
    MatrixXd U_basisR(rank, nsv);
    
    for (int i = 0; i < I2E.rows(); i++)
    {
        int elemL = I2E(i,0)-1; int elemR = I2E(i,2)-1; 
        int edgeL = I2E(i,1); int edgeR = I2E(i,3);
 
        for (int k = 0; k < rank; k++)
        {
            R_ki(k, all) = R_k((rank*(elemL))+k,all); // elemL -> left element         

            U_basisL(k, all) = U_basis_all((rank * elemL) + k, all); // Basis functions on elemL

            R_rki(k, all) = R_k((rank*(elemR))+k,all); // elemR -> right element

            U_basisR(k, all) = U_basis_all((rank * elemR) + k, all); // Basis functions on elemR
        }
        // MatrixXd Res_elem = Res_Elem_Int_Indv(BQ2, BQ2g, w2, iJe, dJe, U_basis, R_ki, gamma, p, q);
        Res Resi_edge;
        Resi_edge = Res_Elem_Edge_Indv(elemL, edgeL, edgeR, BQ1, s, w1, nvec, U_basisL, U_basisR, R_ki, R_rki, gamma, p, q);  // structure returned
	    MatrixXd smag_edge = Resi_edge.smag;
	    MatrixXd ResL = Resi_edge.Resl;
	    MatrixXd ResR = Resi_edge.Resr;
        //cout << "elemL: " << elemL << " ResL: " << ResL << "\n";
        //cout << "elemR: " << elemR << " ResR: " << ResR << "\n";

        for (int k = 0; k < rank; k++)
        {
            R_k((rank*(elemL))+k,all) = ResL(k, all);
            R_k((rank*(elemR))+k,all) = ResR(k, all);
        }

        if (edgeL==1)
        {
            smag(elemL, edgeL-1) = sqrt(2)*smag_edge(0,0);
	        smag(elemR, edgeR-1) = sqrt(2)*smag_edge(0,0);
        } else
        {
            smag(elemL, edgeL-1) = smag_edge(0,0);
	        smag(elemR, edgeR-1) = smag_edge(0,0);
        }
        
    }
    Res_entire = R_k;
    //cout << "after internal \n";
    //cout << Res_entire << "\n";

    // Boundaries
    MatrixXd UinfR(rank,nsv);

    for (int i = 0; i < B2E.rows(); i++)
    {
        int elemL = B2E(i,0) - 1;
        int edgeL = B2E(i,1);
        int BC = B2E(i,2); 

        for (int k = 0; k < rank; k++)
        {
            R_ki(k, all) = Res_entire((rank*(elemL))+k,all); // elemL -> left element
            U_basisL(k, all) = U_basis_all((rank * elemL) + k, all); // Basis functions on elemL
            UinfR(k,all) = Uinf((rank*elemL) + k, all);
	    //R_rki(k, all) = R_k((rank*(elemR))+k,all); // elemL -> left element
            //U_basisR(k, all) = U_basis_all((rank * elemR) + k, all); // Basis functions on elemL
            
        }

        // MatrixXd Res_elem = Res_Elem_Int_Indv(BQ2, BQ2g, w2, iJe, dJe, U_basis, R_ki, gamma, p, q);
        Res Resi_edge;
        Resi_edge = Res_Elem_Edge_Indv_BC(BC, elemL, edgeL, BQ1, UinfR, s, w1, nvec, U_basisL, R_ki, gamma, p, q);  // structure returned
        MatrixXd smag_edge = Resi_edge.smag;

	    MatrixXd ResL = Resi_edge.Resl;
        for (int k = 0; k < rank; k++)
        {
            Res_entire((rank * elemL) + k, all) = ResL(k, all);
             //Res_entire((rank * elemR) + k, all) = Res_entire((rank * elemR) + k, all) + Resi_edge.Res2;
        }

        if (edgeL==1)
        {
            smag(elemL, edgeL-1) = sqrt(2)*smag_edge(0,0);
        } else
        {
            smag(elemL, edgeL-1) = smag_edge(0,0);
        }
    }
    //cout << "total \n";
    //cout << Res_entire << "\n";
    struct Res_Fin R_full;
    R_full.R = Res_entire;
    R_full.smag = smag;
    // You'd want to subtract/add edge residues from Res_entire, so pass that as input; can be clarified from notes
    return R_full;
}

// full residual calculation
struct Res_Fin CalcResid(MatrixXd Uinf, MatrixXd Ubasis, MatrixXi I2E, MatrixXi B2E, MatrixXd BQ2, MatrixXd BQ2g, MatrixXd BQ1, MatrixXd s, MatrixXd w2, MatrixXd w1, MatrixXd nvec, int p, int q, double gamma, MatrixXd detJ, MatrixXd invJcb)
{
    // declaring variables
    MatrixXd R(Ubasis.rows(), 4);
    int rank = ((p+1)*(p+2))/2;

    // initializing residual to 0
    R.setZero();

    // element interior calculation - fully self-consistent just need to add/subtract to the residual
    MatrixXd Res_Int = Res_Elem_Int_Total(BQ2, BQ2g, w2, invJcb, detJ, Ubasis, R, gamma, p, q);
    //cout << "from interior \n";
    //cout << Res_Int << "\n";
    // edge calculations
    struct Res_Fin R_full = Res_Elem_Edge_Total(Uinf, BQ1, w1, invJcb, Ubasis, Res_Int, s, nvec, gamma, p, q, I2E, B2E);

    return R_full;

}

MatrixXd TimeStep(double CFL, MatrixXd A, MatrixXd smag, int p)
{
    int rank = (p+1)*(p+2)/2;

    MatrixXd dt(rank*A.rows(), 1);
    MatrixXd val(1,1);

    for (int i = 0; i<A.rows(); i++)
    {
        
	val(0,0)= 2*CFL*A(i,0)/smag(i,all).rowwise().sum().sum();
	
	for (int r=0; r<rank; r++)
	{
		dt(i+r, 0) = val(0,0);
	}
    }
    
    return dt;
}

MatrixXd invMassMult(MatrixXd iM, MatrixXd R, int p)
{

    int rank = (p+1)*(p+2)/2;
    int np = R.rows();

    int iter = np/rank;
    
    MatrixXd iMM;
    MatrixXd RR;
    MatrixXd F(np, 4);
    F.setZero();

    for (int i=0; i < iter; i++) {
        for (int j=0; j<4; j++) {
            iMM = iM(seq(rank*i,rank*(i+1)-1),all);
            RR = R(seq(rank*i,rank*(i+1)-1),j);
            F(seq(rank*i,rank*(i+1)-1),j) = iMM*RR;
        }
    }

    return F;
}

MatrixXd StateUpdate(MatrixXd dt, MatrixXd F, MatrixXd U, int p)
{
	int rank = (p+1)*(p+2)/2;
	int np = F.rows();

	int iter = np/rank;
	int j=0;

	MatrixXd tstep(1,1);
	MatrixXd FF(rank, 4);

	for (int i = 0; i<iter; i++)
	{
	        tstep(0,0) = dt(i,0);
	        FF(all, all) = F(seq(j, j+rank-1), all);
			
		for (int k=0; k<rank; k++)
		{
			U(j+k, all) = U(j+k, all) + 0.5*tstep(0,0)*FF(k, all);	
		}

		j += rank;
	}
	return U;
}

MatrixXd StateUpdate2(MatrixXd dt, MatrixXd F, MatrixXd U, int p)
{
	int rank = (p+1)*(p+2)/2;
	int np = F.rows();

	int iter = np/rank;
	int j=0;

	MatrixXd tstep(1,1);
	MatrixXd FF(rank, 4);

	for (int i = 0; i<iter; i++)
	{
	        tstep(0,0) = dt(i,0);
	        FF(all, all) = F(seq(j, j+rank-1), all);
			
		for (int k=0; k<rank; k++)
		{
			U(j+k, all) = U(j+k, all) + tstep(0,0)*FF(k, all);	
		}

		j += rank;
	}
	return U;
}

MatrixXd FinalStateUpdate(MatrixXd dt, MatrixXd F0, MatrixXd F1, MatrixXd F2, MatrixXd F3, MatrixXd U, int p)
{
	int rank = (p+1)*(p+2)/2;
	int np = F0.rows();
	int iter = np/rank;
	int j=0;

	MatrixXd tstep(1,1);
	MatrixXd FF0(rank,4);
	MatrixXd FF1(rank,4);
	MatrixXd FF2(rank,4);
	MatrixXd FF3(rank,4);

	for (int i=0; i<iter; i++)
	{
		tstep(0,0) = dt(i,0);
		FF0(all, all) = F0(seq(j, j+rank-1), all);
		FF1(all, all) = F1(seq(j, j+rank-1), all);
		FF2(all, all) = F2(seq(j, j+rank-1), all);
		FF3(all, all) = F3(seq(j, j+rank-1), all);

		for (int k=0; k<rank; k++)
		{
			U(j+k, all) = U(j+k, all) + (tstep(0,0)/6)*(FF0(k, all) + 2*FF1(k, all) + 2*FF2(k,all) + FF3(k,all));
		}
		j += rank;
	}

	return U;
}

int main()
{

    /* Load Mesh Files */
    MatrixXd N = FileRead("c0_q2_nodes.txt", 7267, 2);
    MatrixXd Ed = FileRead("c0_q22_E2N.txt", 2054, 6);
    MatrixXd B2Ed = FileRead("c0_q1_B2E.txt", 160, 3);
    MatrixXd I2Ed = FileRead("c0_q1_I2E.txt", 3001, 4);
    MatrixXd U0 = FileRead("c0_p0_q1_U.txt",2054*6,4);
    /*MatrixXd N = FileRead("UnitCurveN2.txt", 12, 2);
    MatrixXd Ed = FileRead("UnitCurveE2.txt", 3, 6);
    MatrixXd B2Ed = FileRead("UnitCurveB2E.txt", 5, 3);
    MatrixXd I2Ed = FileRead("UnitCurveI2E.txt", 2, 4);*/

    cout << "Read in Files \n";

    int p = 2;
    int q = 2;
    double gamma = 1.4;

    /* reading in .gri file and getting the pertinent information*/
    // B2E, I2E, nodes, elements, curved elements

    /* pre-computed variables */
    MatrixXi E = Ed.cast<int>();
    MatrixXi B2E = B2Ed.cast<int>();
    // for freestream testing
    /*for (int i=0; i<B2E.rows(); i++) {
        B2E(i,2) = -1;
    }*/
    MatrixXi I2E = I2Ed.cast<int>();
    struct Pre S = PreComp(N, E, p, q);
    MatrixXd iM = S.iMM;
    MatrixXd BQ2 = S.BQ2;
    MatrixXd BQ2g = S.BQ2g;
    MatrixXd w2 = S.w2;
    MatrixXd invJcb = S.iJ;
    MatrixXd detJ = S.dJ;
    MatrixXd BQ1 = S.BQ1;
    MatrixXd w1 = S.w1;
    MatrixXd n = S.nvec;
    MatrixXd A = S.A;
    MatrixXd s = S.s1;
    
    /* initialize state to free stream for Lagrange basis */

    // calculate freestream state
    MatrixXd Uinf = FreeStream(1.4, 0.25, 8*M_PI/180);
    cout << "Calculate free stream \n";

    // initialize solution to freestream state everywhere (on all basis points)
    int rank = ((p+1)*(p+2))/2;
    MatrixXd U(E.rows()*rank, 4);
    MatrixXd Ui(E.rows()*rank, 4);
    for (int i=0; i<E.rows(); i++)
    {   
        for (int r=0; r<rank; r++) {
            U(i*rank+r,all) = U0(i,all);
            Ui(i*rank+r,all) = Uinf; 
        }
    }


    /* begin loop over time steps */

    // looping over stages in the time scheme
    double err = 100;
    int c = 0;
    double CFL = 0.01;
    MatrixXd err_ct(200000,1);
    MatrixXd RCalc; 

    cout << "Beginning time stepping \n";
    while (c < 20000 && err > 1e-5) 
    {   
        // RK4 time stepping
        struct Res_Fin R1 = CalcResid(Ui, U, I2E, B2E, BQ2, BQ2g, BQ1, s, w2, w1, n,  p,  q,  gamma,  detJ,  invJcb);
        RCalc = R1.R;
        //cout << RCalc << "\n";
	    MatrixXd dt = TimeStep(CFL, A, R1.smag, p);
        MatrixXd F0 = invMassMult(-iM, RCalc, p);
	    MatrixXd U1 = StateUpdate(dt, F0, U, p);
        struct Res_Fin R2 = CalcResid(Ui, U1, I2E, B2E, BQ2, BQ2g, BQ1, s, w2, w1, n,  p,  q,  gamma,  detJ,  invJcb);
	    RCalc = R2.R;
        //dt = TimeStep(CFL, A, R2.smag,p);
        MatrixXd F1 = invMassMult(-iM, RCalc, p);
	    MatrixXd U2 = StateUpdate(dt, F1, U, p);
        //cout << RCalc <<"\n";
        struct Res_Fin R3 = CalcResid(Ui, U2, I2E, B2E, BQ2, BQ2g, BQ1, s, w2, w1, n,  p,  q,  gamma,  detJ,  invJcb);
        RCalc = R3.R;
        //dt = TimeStep(CFL, A, R3.smag,p);
        MatrixXd F2 = invMassMult(-iM, RCalc, p);
	    MatrixXd U3 = StateUpdate2(dt, F2, U, p);
	//cout << RCalc << "\n";
        struct Res_Fin R4 = CalcResid(Ui, U3, I2E, B2E, BQ2, BQ2g, BQ1, s, w2, w1, n,  p,  q,  gamma,  detJ,  invJcb);
        RCalc = R4.R;
        //dt = TimeStep(CFL, A, R4.smag,p);;
        MatrixXd F3 = invMassMult(-iM, RCalc, p);
    	U = FinalStateUpdate(dt, F0, F1, F2, F3, U, p); 
	//cout << RCalc << "\n";
        err = (RCalc.cwiseAbs()).sum();
	    err_ct(c,0) = err;
    
        c = c + 1;
        if (c%1 == 0)
        {   
            //cout << "Example State: " << U(2051*rank,all) << "\n";
            //cout << "Example Res: " << RCalc(2051*rank,all) << "\n";
            cout << "Iteration Number: " << c << "\n";
            cout << "Residual Number: " << err << "\n";
            FileWrite("c0_p2_q2_U.txt",U);
            FileWrite("c0_p2_q2_e.txt",err_ct);
        }
	
	
    //cout << "BQ1 \n" << BQ1;
    } 
    cout << "Iteration Number:" << c << "\n";
    cout << "Residual Number:" << err << "\n";
    //cout << "Final State: \n";
    //cout << U << "\n";

    /*cout << "elem 3 coords: \n";
    for (int i=0; i<rank; i++) {
        cout << "Basis: " << i << " Coords: " << N(E(2051,i)-1,all) << "\n";
    }*/

    FileWrite("c0_p2_q2_U.txt",U);
    return 0;

}
